
## string 类的相关函数

**replace()** 

```cpp
```

## string 类型转换

### string 与 char* 、char[] 之间的转换

### 1.string` 转 `char*

三种方法可以将 str 转换为 `char*` 类型，分别是：`data();` `c_str();` `copy();`

`c_str()` 方法，如：  

```cpp
string str=“world”;
const char *p = str.c_str();//同上，要加const或者等号右边用char*
```

`data()` 方法，如：

```cpp
string str = "hello";
char * p= (char*)str.data();
```

同时有一点需要说明，这里在 devc++ 中编译需要添加const，否则会报错 invalid conversion from const      char*  to char *，这里可以再前面加上const或者在等号后面给强制转化成char*的类型。

`const char*` 是不能直接赋值到 `char *` 的,这样编译都不能通过,理由:假如可以的话,那么通过 `char*` 就可以修改 `const char*` 指向的内容了,这是不允许的。所以 `char*` 要另外开辟新的空间，即上面的形式。

`copy()` 方法，如：

```cpp
string str="hmmm";
char p[50];
str.copy(p, 5, 0);//这里5代表复制几个字符，0代表复制的位置，
*(p+5)=‘\0’;//注意手动加结束符！！！
```

### 2.char * 转 string

   可以直接赋值。

```cpp
string s;
char *p = "hello";//直接赋值
s = p;
```

这里有一点要说明，当声明了 string 类型变量 s 后，用 printf("%s",s); 是会出错的，因为 “%s”要求后面的对象的首地址。但是string不是这样的一个类型。

所以肯定出错。

### 3.string 转 char[]

   这个由于我们知道 string 的长度，可以根据 length() 函数得到，又可以根据下标直接访问，所以用一个循环就可以赋值了。

```html
string pp = "dagah";
char p[8];
int i;
for( i=0;i<pp.length();i++)
	p[i] = pp[i];
p[i] = '\0';
```



### 4..char[] 转 string

可以直接赋值。

### `std::vector<std::string>` 转换成 string

```cpp
#include <vector>
#include <string>
#include <numeric>    // 函数所在的库
#include <iostream>

int main()
{
	string strData;
	std::vector<std::string> vec = { "hello","world","!"};
	strData = accumulate(vec.begin(), vec.end(), strData); // 用到的头文件 #include<numeric>
	std::cout << strData << std::endl;

}
```



## 一个 string 类型的字符串可以有多长？

这个确实有上限，可以通过std::string::max_size()函数获得。

该函数获取的上限，其实是unsigned(-1)的值。所以依据平台和编译选项的不同，这个值会有变化。

在某些十六位嵌入式开发环境中，这个值是65535，也就是十六进制的0xFFFF

大部分32位环境或者系统中，这个值是4,294,967,295，也就是十六进制0xFFFFFFFF。这大约有4G字节的样子。

极少数服务器里面64位环境下，这个值是18,446,744,073,709,551,615，也就是十六进制的0xFFFFFFFFFFFFFFFF。这大约是16E字节的样子（1E=1G个G，也就是

2的30次方个G）。因为这种服务器其实是一个类似于天河计算机一样的网络集群，内存容量非常大（以T计算，1T=1024G），硬盘容量近乎无限。

不过实际上使用的时候，这个大小是受限于计算机内存容量的。但对于内存可以承受的范围内，可以简单的认为string支持的字符串大小没有上限，或者上限非常大几乎用不到。 

