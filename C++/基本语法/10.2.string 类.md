# string 类

## string 类的相关函数

**replace()** 

```cpp
```



## string 与 char* 、char[] 之间的转换

### string` 转 `char*

三种方法可以将 str 转换为 `char*` 类型，分别是：`data();` `c_str();` `copy();`

`data()` 方法，如：

```cpp
string str = "hello";
const char* p = str.data();//加const  或者用char * p= (char*)str.data();的形式
```

同时有一点需要说明，这里在 devc++ 中编译需要添加const，否则会报错 invalid conversion from const      char*  to char *，这里可以再前面加上const或者在等号后面给强制转化成char*的类型。

`const char*` 是不能直接赋值到 `char *` 的,这样编译都不能通过,理由:假如可以的话,那么通过 `char*` 就可以修改 `const char*` 指向的内容了,这是不允许的。所以 `char*` 要另外开辟新的空间，即上面的形式。

`c_str()` 方法，如：  

```cpp
string str=“world”;
const char *p = str.c_str();//同上，要加const或者等号右边用char*
```

`copy()` 方法，如：

```cpp
string str="hmmm";
char p[50];
str.copy(p, 5, 0);//这里5代表复制几个字符，0代表复制的位置，
*(p+5)=‘\0’;//注意手动加结束符！！！
```

### char * 转 string

   可以直接赋值。

```cpp
string s;
char *p = "hello";//直接赋值
s = p;
```

这里有一点要说明，当声明了 string 类型变量 s 后，用 printf("%s",s); 是会出错的，因为 “%s”要求后面的对象的首地址。但是string不是这样的一个类型。

所以肯定出错。

### string转char[]

   这个由于我们知道 string 的长度，可以根据 length() 函数得到，又可以根据下标直接访问，所以用一个循环就可以赋值了。

```html
string pp = "dagah";
char p[8];
int i;
for( i=0;i<pp.length();i++)
	p[i] = pp[i];
p[i] = '\0';
```



### char[] 转string

可以直接赋值。

