# 内联函数

- 函数调用是有时间和空间开销的，执行函数前需要做很多工作。
- 为了消除函数调用的时空开销，C++ 在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。这种在函数调用处直接嵌入函数体的函数称为内联函数（Inline Function）
- 使用内联函数的缺点，编译后的程序会存在多份相同的函数拷贝，如果内联函数的函数体非常大，那么编译后的程序体积也将会变得很大，所以，一般只将那些短小的、频繁调用的函数声明为内联函数。
- 函数作 inline 声明只是程序员对编译器提出的一个建议，而不是强制性的，并非一经指定为 inline 编译器就必须这样做。编译器有自己的判断能力，它会根据具体情况决定是否这样做。
- 和宏一样，内联函数可以定义在头文件中（不用加 static 关键字），**不建议这样做很容易出错**
- inline 关键字可以只在函数定义处添加，也可以只在函数声明处添加，也可以同时添加；但是在函数声明处添加 inline 关键字是无效的，编译器会忽略函数声明处的 inline 关键字，**不建议在声明处添加 inline**
- **建议在什么地方使用内联函数就在哪里定义**

```c++
#include <iostream>
using namespace std;
//内联函数，交换两个数的值
inline void swap(int *a, int *b){
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}
int main(){
    int m, n;
    cin>>m>>n;
    cout<<m<<", "<<n<<endl;
    swap(&m, &n);
    cout<<m<<", "<<n<<endl;
    return 0;
}
```

## 用内联函数代替宏

- c 语言中宏是可以带参数的，它在形式上和函数非常相似。不过不像函数，宏仅仅是字符串替换，不是按值传递，所以在编写宏时要特别注意，一不小心可能就会踩坑。

- 用宏来求平方根是宏使用经典的例子

```c++
#include <iostream>
using namespace std;
#define SQ(y) y*y
int main(){
    int n, sq;
    cin>>n;
    sq = SQ(n);
    cout<<sq<<endl;
    return 0;
}
```

从表面上看这个宏定义是正确的，但当我们将宏调用`SQ(n)`换成`SQ(n+1)`后，就会出现意想不到的状况：

```
#include <iostream>
using namespace std;
#define SQ(y) y*y
int main(){    
int n, sq;    
cin>>n;    
sq = SQ(n+1);    
cout<<sq<<endl;    
return 0;}
```

运行结果：
```
9↙
19
```
我们期望的结果是 100，但这里却是 19，两者大相径庭。这是因为，宏展开仅仅是字符串的替换，不会进行任何计算或传值，上面的`sq = SQ(n+1);`在宏展开后会变为`sq = n+1*n+1;`，这显然是没有道理的。

如果希望得到正确的结果，应该将宏定义改为如下的形式：

```
#define SQ(y) (y)*(y)
```
这样宏调用`sq = SQ(n+1);`就会展开为`sq = (n+1)*(n+1);`，得到的结果就是 100。

如果你认为这样就万事大吉了，那下面的结果会让你觉得考虑不周：

```
#include <iostream>
using namespace std;
#define SQ(y) (y)*(y)
int main(){
    int n, sq;
    cin>>n;
    sq = 200 / SQ(n+1);
    cout<<sq<<endl;
    return 0;
}
```

运行结果：
```
9↙
200
```
之所以会出现这么奇怪的结果，是因为宏调用`sq = 200 / SQ(n+1);`会被展开为`sq = 200 / (n+1) * (n+1);`，当 n 被赋值 9 后，相当于`sq = 200 / 10 * 10`，结果显然是 200。

要想得到正确的结果，还应该对宏加以限制，在两边增加`( )`，如下所示：

```c++
#define SQ(y) ( (y)*(y) )
```
这样宏调用`sq = 200 / SQ(n+1);`就会展开为`sq = 200 / ( (n+1) * (n+1) );`，得到的结果就是 2。

说了这么多，我最终想强调的是，宏定义是一项“细思极密”的工作，一不小心就会踩坑，而且不一定在编译和运行时发现，给程序埋下隐患。

如果我们将宏替换为内联函数，情况就没有那么复杂了，程序员就会游刃有余，请看下面的代码：

```c++
#include <iostream>
using namespace std;
inline int SQ(int y){ return y*y; }
int main(){
    int n, sq;
    cin>>n;
    //SQ(n)
    sq = SQ(n);
    cout<<sq<<endl;
    //SQ(n+1)
    sq = SQ(n+1);
    cout<<sq<<endl;
    //200 / SQ(n+1)
    sq = 200 / SQ(n+1);
    cout<<sq<<endl;
    return 0;
}
```

看，一切问题迎刃而解！发生函数调用时，编译器会先对实参进行计算，再将计算的结果传递给形参，并且函数执行完毕后会得到一个值，而不是得到一个表达式，这和简单的字符串替换相比省去了很多麻烦，所以在编写C++代码时我推荐使用内联函数来替换带参数的宏。

内联函数在编译时会将函数调用处用函数体替换，编译完成后函数就不存在了，所以在链接时不会引发重复定义错误。这一点和宏很像，宏在预处理时被展开，编译时就不存在了。从这个角度讲，内联函数更像是编译期间的宏。

> 一是消除函数调用时的开销，二是取代带参数的宏。不过我更倾向于后者，取代带参数的宏更能凸显内联函数存在的意义。

