
- c++ 中定义一个函数

```c++
return_type function_name( parameter list )
{
   body of the function
}
```

- 和 c 语言一样，当你在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，你应该在调用函数的文件顶部声明函数。

```c++
return_type function_name( parameter list );
```

## 函数传参

| 调用类型 | 描述                                                           |
|:---- |:------------------------------------------------------------ |
| 传值调用 | 该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。             |
| 指针调用 | 该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 |
| 引用调用 | 该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 |

## 函数参数的默认值

- c++ 的函数参数可以指定默认值，当没有某个参数没有传递值过来，就使用默认值执行函数
- C++规定，默认参数只能放在形参列表的最后，而且一旦为某个形参指定了默认值，那么它后面的所有形参都必须有默认值

```c++
void func(int a, int b=10, int c=20){ }
void func(int a, int b, int c=20){ }
```

- 在以后设计类时你将发现，通过使用默认参数，可以减少要定义的析构函数、方法以及方法重载的数量。

```c++
#include <iostream>
using namespace std;

int sum(int a, int b=20)
{
  int result;

  result = a + b;

  return (result);
}

int main ()
{
   // 局部变量声明
   int a = 100;
   int b = 200;
   int result;

   // 调用函数来添加值
   result = sum(a, b);
   cout << "Total value is :" << result << endl;

   // 再次调用函数
   result = sum(a); // 没有参数 b 的值
   cout << "Total value is :" << result << endl;

   return 0;
}
```

### 到底在声明中还是定义中指定默认参数

先看一个例子，定义和声明都在同一个文件中，这样编译运行会报错

```c++
#include <iostream>
using namespace std;
void func(int a, int b = 10, int c = 36);
int main(){
    func(99);
    return 0;
}
void func(int a, int b = 10, int c = 36){
    cout<<a<<", "<<b<<", "<<c<<endl;
}
```

当把定义和声明分开，放在两个文件中

```c++
// main.cpp
#include <iostream>
using namespace std;
void func(int a, int b = 10, int c = 20);
int main(){
    func(99);
    return 0;
}
// utils.cpp
#include <iostream>
using namespace std;
void func(int a, int b = 10, int c = 36){
    cout<<a<<", "<<b<<", "<<c<<endl;
}
```

这样就可编译运行成功。

- 这是因为C++ 规定，在给定的作用域中只能指定一次默认参数。

- C语言有四种作用域，分别是函数原型作用域、局部作用域（函数作用域）、块作用域、文件作用域（全局作用域），C++ 也有这几种作用域。

## 函数重载

C++ 允许多个函数拥有相同的名字，只要它们的参数列表不同就可以，这就是函数的重载（Function Overloading）。借助重载，一个函数名可以有多种用途。

```c++
void swap(int *a, int *b);      //交换 int 变量的值
void swap(float *a, float *b);  //交换 float 变量的值
void swap(char *a, char *b);    //交换 char 变量的值
void swap(bool *a, bool *b);    //交换 bool 变量的值
```

### C++ 是如何做到函数重载的

C++代码在编译时会根据参数列表对函数进行重命名，例如`void Swap(int a, int b)`会被重命名为`_Swap_int_int`，`void Swap(float x, float y)`会被重命名为`_Swap_float_float`。

当发生函数调用时，编译器会根据传入的实参去逐个匹配，以选择对应的函数，如果匹配失败，编译器就会报错，这叫做重载决议（Overload Resolution）。

> 从这个角度讲，函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。

### C++ 函数重载的歧义性

#### 单个参数

```c++
#include <iostream>
using namespace std;
//1号函数
void func(char ch){
    cout<<"#1"<<endl;
}
//3号函数
void func(long m){
    cout<<"#3"<<endl;
}
//4号函数
void func(double f){
    cout<<"#4"<<endl;
}
int main(){
    short s = 99;
    float f = 84.6;
  
    func('a');
    func(s);
    func(49);
    func(f);
    return 0;
}
```

这段代码在编译时发生了错误，大概的意思是：`func(s)`和`func(49)`这两个函数发生调用错误，它们可以匹配三个重载函数中的任何一个，编译器不知道如何抉择。

这着实有点让人摸不着头脑！根据以往的编程经验，s 和 49 不都应该被转换成 long 类型，从而匹配3号函数`void func(long m)`吗？这种推论在一般的函数调用或者四则运算中确实没错，但它不一定适用于重载函数！

C++ 标准规定，在进行重载决议时编译器应该按照下面的优先级顺序来处理实参的类型：

| 优先级                 | 包含的内容                                                   | 举例说明                                                     |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 精确匹配               | 不做类型转换，直接匹配                                       | （暂无说明）                                                 |
| 只是做微不足道的转换   | 从数组名到数组指针、从函数名到指向函数的指针、从非 const 类型到 const 类型。 |                                                              |
| 类型提升后匹配         | 整型提升                                                     | 从 bool、char、short 提升为 int，或者从 char16_t、char32_t、wchar_t 提升为 int、long、long long。 |
| 小数提升               | 从 float 提升为 double。                                     |                                                              |
| 使用自动类型转换后匹配 | 整型转换                                                     | 从 char 到 long、short 到 long、int 到 short、long 到 char。 |
| 小数转换               | 从 double 到 float。                                         |                                                              |
| 整数和小数转换         | 从 int 到 double、short 到 float、float 到 int、double 到 long。 |                                                              |
| 指针转换               | 从 int * 到 void *。                                         |                                                              |

C++ 标准还规定，编译器应该按照从高到低的顺序来搜索重载函数，首先是精确匹配，然后是类型提升，最后才是类型转换；一旦在某个优先级中找到唯一的一个重载函数就匹配成功，不再继续往下搜索。

如果在一个优先级中找到多个（两个以及以上）合适的重载函数，编译器就会陷入两难境地，不知道如何抉择，编译器会将这种模棱两可的函数调用视为一种错误，因为这些合适的重载函数同等“优秀”，没有一个脱颖而出，调用谁都一样。这就是函数重载过程中的二义性错误。

在例1中，`func('a')`、`func(49)`分别和`void func(char)`、`void func(int)`精确匹配；`func(s)`没有精确匹配的重载函数，编译器将 s 的类型提升为 int 后和`void func(int)`匹配成功；`func(f)`也是类似的道理，将 f 提升为 double 类型后和`void func(double)`匹配成功。

在例2中，`func(s)`、`func(49)`没有精确匹配的重载函数，将它们的类型都提升为 int 后仍然不能匹配，接下来进入自动类型转换阶段，发现 s 被转换为 char（整型转换）、long（整型转换）、double（整数和小数转换）后都有比较合适的函数，而且它们在同一个优先级中，谁也不比谁优秀，调用哪个都一样，产生了二义性，所以编译器会报错。

注意，类型提升和类型转换不是一码事！类型提升是积极的，是为了更加高效地利用计算机硬件，不会导致数据丢失或精度降低；而类型转换是不得已而为之，不能保证数据的正确性，也不能保证应有的精度。类型提升只有上表中列出的几种情况，其他情况都是类型转换。

### 多个参数

当重载函数有多个参数时也会产生歧义性，而且情况更加复杂。C++ 标准规定，如果有且只有一个函数满足下列条件，则匹配成功：

- 该函数对每个实参的匹配都不劣于其他函数；
- 至少有一个实参的匹配优于其他函数。

```c++
void func(int, int);  //①
void func(char, int, float);  //②
void func(char, long, double);  //③
```

当有如下代码

```c++
short n = 99;
func('@', n, 99);
func('@', n, 99.5);
```

函数原型`func(int, int)`只有两个参数，而函数调用有三个参数，很容易看出来不匹配，在初次筛选时就会被过滤掉，接下来我们只讨论②③个函数原型。

\1) 先来看第一个函数调用。如果只考虑第一个实参`'@'`，那么②③两个函数都能够精确匹配，谁也不比谁优秀，是平等的；如果只考虑第二个实参`n`，对于②，需要把 short 提升为 int（类型提升），对于③，需要把 short 转换为 long（类型转换），类型提升的优先级高于类型转换，所以②胜出；如果只考虑第三个实参`99`，②③都要进行类型转换，没有哪一个能胜出，它们是平等的。

从整体上看，②③在第一、三个实参的匹配中是平等的，但②在第二个实参的匹配中胜出，也就是说，②对每个实参的匹配都不劣于③，但有一个实参的匹配优于③，所以②最终脱颖而出，成为被调用函数。

\2) 再来看第二个函数调用。只考虑第一个实参时②③是平等的，没有谁胜出；只考虑第二个实参时②胜出；只考虑第三个实参时，②需要类型转换，③能够精确匹配，精确匹配的优先级高于类型转换，所以③胜出。

从整体上看，②③在第一个实参的匹配中是平等的，②在第二个实参的匹配中胜出，③在第三个实参的匹配中胜出，它们最终“打成了平手”，分不清孰优孰劣，所以编译器不知道如何抉择，会产生二义性错误。

