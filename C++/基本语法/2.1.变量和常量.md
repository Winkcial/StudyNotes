# 变量

## 声明变量

```c++
extern int a;    // d 和 f 的声明 
int d = 3, f = 5;           // 定义并初始化 d 和 f
byte z = 22;                // 定义并初始化 z
char x = 'x';               // 变量 x 的值为 'x'
```

- 关于 `extern` 只是声明了有一个变量 a 存在，具体 a 在哪定义的，需要编译器编译的时候去找。
  - 如果是 `extern a=1;` 这样既声明又初始化的只能放在函数体外
  - 另外 extern 可以修饰函数 `extern void Fun(); // Test.h 函数声明，extern 用于标识次函数为外部可调用函数 `

## 变量类型转换

### 自动转换

- 若参与运算量的类型不同，则先转换成同一类型，然后进行运算。
- 转换按数据长度增加的方向进行，以保证精度不降低。如int型和long型运算时，先把int量转成long型后再进行运算。   a、若两种类型的字节数不同，转换成字节数高的类型   b、若两种类型的字节数相同，且一种有符号，一种无符号，则转换成无符号类型
- 所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算。
- char型和short型参与运算时，必须先转换成int型。
- 在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换为左边量的类型。如果右边量的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度:

### 强制转换

```
（类型说明符）（表达式)
int a = 1;
double b = 2.1;
cout << "a + b = " << a + (int)b << endl;  //输出为a + b = 3
```

## 变量作用域

一共三个地方、局部变量、全局变量、函数形参

**C++ 全局变量、局部变量、静态全局变量、静态局部变量的区别**

C++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：**全局作用域**，**局部作用域**，**语句作用域**，**类作用域**，**命名空间作用域和文件作用域**。

**从作用域看：**

全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。

静态局部变量具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。

局部变量也只有局部作用域，它是自动对象（auto），它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。

静态全局变量也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。

**从分配内存空间看：**

全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间。

全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。

- 1)、静态变量会被放在程序的静态数据存储区（数据段）(全局可见)中，这样可以在下一次调用的时候还可以保持原来的赋值。这一点是它与堆栈变量和堆变量的区别。
- 2)、变量用static告知编译器，自己仅仅在变量的作用范围内可见。这一点是它与全局变量的区别。

从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。应予以注意。

**Tips:**

- A、若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度；
- B、若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度；
- C、设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题，因为他们都放在静态数据存储区，全局可见；
- D、如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量(这样的函数被称为：带“内部存储器”功能的的函数)
- E、函数中必须要使用static变量情况:比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。

**static 全局变量**:改变作用范围，不改变存储位置

**static 局部变量**：改变存储位置，不改变作用范围

**静态函数** ：在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。

如果在一个源文件中定义的函数，只能被本文件中的函数调用，而不能被同一程序其它文件中的函数调用，这种函数也称为内部函数。定义一个内部函数，只需在函数类型前再加一个“static”关键字即可。

| 数据类型    | 初始化默认值 |
|:------- |:------ |
| int     | 0      |
| char    | '\0'   |
| float   | 0      |
| double  | 0      |
| pointer | NULL   |

### 字符 '0' 和 '\0' 及整数 0 的区别

- **字符 '0'**：`char c = '0';` 它的 ASCII 码实际上是 48，内存中存放表示：00110000。

- **字符 '\0'**： ASCII 码为 0，表示一个字符串结束的标志。这是转义字符（整体视为一个字符）。由于内存中存储字符，依然是存储的是对应字符集的字符编码，所以内存中的表现形式为 00000000。

- **整数 0 ：** 内存中表示为 00000000 00000000 00000000 00000000，虽然都是 0，但是跟上面字符 '\0' 存储占用长度是不一样的。

## 常量

- 在C语言中，const  用来限制一个变量，表示这个变量不能被修改，我们通常称这样的变量为常量（Constant），
- 在C++中，const 的含义并没有改变，只是对细节进行了一些调整，以下是最主要的两点。

## C++中的 const 更像编译阶段的 #define

先来看下面的两条语句：

```
const int m = 10;int n = m;
```

我们知道，变量是要占用内存的，即使被 const 修饰也不例外。m、n 两个变量占用不同的内存，`int n = m;`表示将 m 的值赋给 n，这个赋值的过程在C和C++中是有区别的。

在C语言中，编译器会先到 m 所在的内存取出一份数据，再将这份数据赋给 n；而在C++中，编译器会直接将 10 赋给 n，没有读取内存的过程，和`int n = 10;`的效果一样。C++ 中的常量更类似于`#define`命令，是一个值替换的过程，只不过`#define`是在预处理阶段替换，而常量是在编译阶段替换。

C++ 对 const 的处理少了读取内存的过程，优点是提高了程序执行效率，缺点是不能反映内存的变化，一旦 const 变量被修改，C++ 就不能取得最新的值。

有读者提出疑问，const 变量不是禁止被修改吗？对，这种说法没错！不过这只是语法层面上的限制，通过指针仍然可以修改。下面的代码演示了如何通过指针修改 const 变量：

```
#include <stdio.h>int main(){    const int n = 10;    int *p = (int*)&n;  //必须强制类型转换    *p = 99;  //修改const变量的值    printf("%d\n", n);    return 0;}
```

> 注意，`&n`得到的指针的类型是`const int *`，必须强制转换为`int *`后才能赋给 p，否则类型是不兼容的。

将代码放到`.c`文件中，以C语言的方式编译，运行结果为`99`。再将代码放到`.cpp`文件中，以C++的方式编译，运行结果就变成了`10`。这种差异正是由于C和C++对 const 的处理方式不同造成的。

在C语言中，使用 printf 输出 n 时会到内存中获取 n 的值，这个时候 n 所在内存中的数据已经被修改成了 99，所以输出结果也是 99。而在C++中，`printf("%d\n", n);`语句在编译时就将 n 的值替换成了 10，效果和`printf("%d\n", 10);`一样，不管 n 所在的内存如何变化，都不会影响输出结果。

当然，这种修改常量的变态代码在实际开发中基本不会出现，本例只是为了说明C和C++对 const 的处理方式的差异：C语言对 const 的处理和普通变量一样，会到内存中读取数据；C++ 对 const 的处理更像是编译时期的`#define`，是一个值替换的过程。

## C++中全局 const 变量的可见范围是当前文件

我们知道，普通全局变量的作用域是当前文件，但是在其他文件中也是可见的，使用`extern`声明后就可以使用，这在一章中进行了深入讲解。下面是多文件编程的演示代码：

代码段1（源文件1）：

```
#include <stdio.h>int n = 10;void func();int main(){    func();    printf("main: %d\n", n);    return 0;}
```

代码段2（源文件2）：

```
#include <stdio.h>extern int n;void func(){    printf("module: %d\n", n);}
```

不管是以C还是C++的方式编译，运行结果都是：
module: 10
main: 10

在C语言中，const 变量和普通变量一样，在其他源文件中也是可见的。修改代码段1，在 n 的定义前面加 const 限制，如下所示：

const int n = 10;

修改后的代码仍然能够正确编译，运行结果和上面也是一样的。这说明C语言中的 const 变量在多文件编程时的表现和普通变量一样，除了不能修改，没有其他区别。

但是如果按照C++的方式编译（将源文件后缀设置为`.cpp`），修改后的代码就是错误的。这是因为 C++ 对 const 的特性做了调整，C++ 规定，全局 const 变量的作用域仍然是当前文件，但是它在其他文件中是不可见的，这和添加了`static`关键字的效果类似。虽然代码段2中使用 extern 声明了变量 n，但是在链接时却找不到代码段1中的 n。

由于 C++ 中全局 const 变量的可见范围仅限于当前源文件，所以可以将它放在头文件中，这样即使头文件被包含多次也不会出错，请看下面的例子。

module.h 代码：

```
const int n = 10;void func();
```

module.cpp 代码：

```
#include <stdio.h>#include "module.h"void func(){    printf("module: %d\n", n);}
```

main.cpp 代码：

```
#include <stdio.h>#include "module.h"int main(){    func();    printf("main: %d\n", n);    return 0;}
```

运行结果：
module: 10
main: 10

C和C++中全局 const 变量的作用域相同，都是当前文件，不同的是它们的可见范围：C语言中 const 全局变量的可见范围是整个程序，在其他文件中使用 extern 声明后就可以使用；而C++中 const 全局变量的可见范围仅限于当前文件，在其他文件中不可见，所以它可以定义在头文件中，多次引入后也不会出错。

如果你使用的是 GCC，那么可以通过添加 extern 关键字来增大 C++ 全局 const 变量的可见范围，如下所示：

extern const int n = 10;

这样 n 的可见范围就变成了整个程序，在其他文件中使用 extern 声明后就可以使用了。不过这种方式只适用于 GCC，不适用于 VS/VC。

## 总结

C++ 中的 const 变量虽然也会占用内存，也能使用`&`获取得它的地址，但是在使用时却更像编译时期的`#define`；`#define`也是值替换，可见范围也仅限于当前文件。

很多C++教程在对比 const 和 #define 的优缺点时提到，#define 定义的常量仅仅是字符串的替换，不会进行类型检查，而 const 定义的常量是有类型的，编译器会进行类型检查，相对来说比 #define 更安全，所以鼓励大家使用 const 代替 #define。

这种说法虽然没错，但是我没有发现不进行类型检查有什么隐患，我在使用 #define 的过程中也没有发现什么缺点，所以我对上面的观点持保留态度，也请大家多多指点。
