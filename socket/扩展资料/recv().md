# recv()

https://baike.baidu.com/item/recv()/10082153

函数原型

```
int recv( _In_ SOCKET s, _Out_ char *buf, _In_ int len, _In_ int flags);
```

不论是客户还是服务器应用程序都用 recv 函数从 TCP 连接的另一端接收数据。该函数的第一个参数指定接收端套接字描述符；

第二个参数指明一个缓冲区，该缓冲区用来存放 recv 函数接收到的数据；

第三个参数指明 buf 的长度；

第四个参数一般置 0 。

这里只描述同步 Socket 的recv函数的执行流程。当应用程序调用recv函数时，

（1）recv 先等待 s 的发送缓冲中的数据被协议传送完毕，如果协议在传送 s 的发送缓冲中的数据时出现网络错误，那么 recv 函数返回SOCKET_ERROR，

（2）如果s的发送缓冲中没有数据或者数据被协议成功发送完毕后，recv 先检查套接字s的接收缓冲区，如果s接收缓冲区中没有数据或者协议正在接收数据，那么 recv 就一直等待，直到协议把数据接收完毕。当协议把数据接收完毕，recv 函数就把s的接收缓冲中的数据copy到buf中（注意协议接收到的数据可能大于buf的长度，所以在这种情况下要调用几次 recv 函数才能把 s 的接收缓冲中的数据 copy完。recv 函数仅仅是 copy 数据，真正的接收数据是协议来完成的）  。

recv函数返回其实际copy的字节数。如果recv在copy时出错，那么它返回SOCKET_ERROR；如果recv函数在等待协议接收数据时网络中断了，那么它返回0。

注意：在Unix系统下，如果recv函数在等待协议接收数据时网络断开了，那么调用recv的进程会接收到一个SIGPIPE信号，进程对该信号的默认处理是进程终止。



返回值：若无错误发生，recv()返回读入的字节数。如果连接已中止，返回0。如果发生错误，返回-1，应用程序可通过perror()获取相应错误信息。