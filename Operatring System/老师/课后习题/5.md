# 第五章

## T7 有哪些 I/O 控制方式？各适用于何种场合？

-  程序 I/O 控制方式
  - 适用于早期无中断的计算机系统中
- 中断驱动 I/O 控制方式
  - 普遍适用于现代计算机系统中
- DMA I/O 控制方式
  - 适用于 I/O 设备为块设备时
- I/O 通道控制方式
  - 当 I/O 设备和主机进行数据交换的是一组数据块时，通常采用 I/O 通道控制方式
    - 需要系统配置相应的通道和通道控制器

## T8 试说明 DMA 工作流程

- CPU 要从磁盘中读取数据时，向磁盘控制器发送一条命令
  - 这条命令被存放在命令寄存器（CR）中
  - 同时还需发送数据将要传送到的内存起始地址、保存在 MAR 中
  - 读取数据的字节数，保存在 DC 中
  - 数据在磁盘中的源地址保存在 DMA 控制器的 I/O 控制逻辑上
- DMA 控制器从磁盘中读取一个字（节）的数据并送入数据寄存器（DR）
- 挪用一个存储器周期，将该字（节）传送到 MAR 指定的内存单元上
- MAR 内容加一，DC 内容减一
- 判断 DC 的值，如果大于 0 ，表示数据未传送完，继续传送下一个数据
- 否则 DMA 控制器中断请求

## T9 引用缓冲的原因是什么？

- 缓和 CPU 和 I/O 设备之间速度不匹配的矛盾
- 减少对 CPU 的中断频率，放宽对 CPU 中断响应时间的限制
- 提高 CPU 和 I/O 设备之间的并行性

## T10 为什么要引入设备独立性？如何实现设备独立性？

- 可以使设备独立于具体的物理设备，使设备分配具有灵活性，同时容易实现 I/O 重定向。
- 需要在设备驱动程序之上设置一层设备独立性软件，用来执行所有 I/O 设备的公用操作，并且向用户层提供统一的接口
- 系统中需要设置一张逻辑设备表 LUT 用来进行逻辑设备到物理设备之间的映射
  - 其中每个表目必须包含逻辑设备名、物理设备名、设备驱动程序入口
- 当应用程序使用逻辑设备名请求分配 I/O 设备时，系统必须为它分匹配物理设备，并且在 LUT 中建立一个表目
- 以后进程利用该逻辑设备名请求 I/O 操作时就可以从 LUT 中得到物理设备名和驱动程序入口

## T18 试说明 SPOOLing 系统的组成？

- 输入井和输出井
- 输出缓冲区和输入缓冲区
- 输入进程 Spi 和输出进程 Spo

## T20 试说明设备驱动程序有哪些特点？

设备驱动程序属于低级的系统例程，它与一般的应用程序及系统程序之间有下述明显差异:

- 驱动程序主要是指在请求 I/O 的进程与设备控制器之间的一个通信和转换程序。
  - 它将进程的I/O请求经过转换后，传送给控制器；又把控制器中所记录的设备状态和I/O操作完成情况及时地反映给请求I/O的进程。 

- 驱动程序与设备控制器和I/O设备的硬件特性紧密相关，因而对不同类型的设备应配置不同的驱动程序。
  - 例如，可以为相同的多个终端设置一个终端驱动程序，但有时即使是同一类型的设备，由于其生产厂家不同，它们也可能并不完全兼容，此时也须为它们配置不同的驱动程序。

- 驱动程序与I/O设备所采用的I/O控制方式紧密相关。
  - 常用的I/O控制方式是中断驱动和DMA方式，这两种方式的驱动程序明显不同，因为后者应按数组方式启动设备及进行中断处理。 

- 由于驱动程序与硬件紧密相关，因而其中的一部分必须用汇编语言书写。
  - 目前有很多驱动程序的基本部分，已经固化在 ROM 中。

- 驱动程序应允许可重入。
  - 一个正在运行的驱动程序常会在一次调用完成前被再次调用。例如，网络驱动程序正在处理一个到来的数据包时，另一个数据包可能到达。

- 驱动程序不允许系统调用。但是为了满足其与内核其它部分的交互，可以允许对某些内核过程的调用。
  - 如通过调用内核过程来分配和释放内存页面作为缓冲区，以及调用其它过程来管理MMU定时器、DMA控制器、中断控制器等。

## T21 设备驱动程序应该完成那些功能？

- 接收由设备独立性软件发来的命令和参数，并将命令中的抽象要求转换为具体要求，例如，将磁盘块号转换为磁盘的盘面、磁道号及扇区号。
- 检查用户 I/O 请求的合法性，了解 I/O 设备的状态，传递有关参数，设置设备的工作方式。
- 发出 I/O 命令。如果设备空闲，便立即启动I/O设备去完成指定的I/O操作；如果设备处于忙碌状态，则将请求者的请求块挂在设备队列上等待。 
- 及时响应由控制器或通道发来的中断请求，并根据其中断类型调用相应的中断处理程序进行处理。
- 对于设置有通道的计算机系统，驱动程序还应能够根据用户的I/O请求，自动地构成通道程序。

## T22 设备中断处理程序通常需要完成那些任务？

- 唤醒被阻塞的驱动进程
- 保护被中断的 CPU 环境
- 转入相应设备的中断程序
- 中断处理
- 恢复被中断进程的现场

## T23 磁盘访问时间由哪几部分组成？如何计算这些时间？

　　1)寻道时间T~s~
　　**这是指把磁臂(磁头)移动到指定磁道上所经历的时间。**该时间是启动磁臂的时间s与磁头移动n条磁道所花费的时间之和，即 
$$
T_s=m\times n +s
$$
其中，m是一常数，与磁盘驱动器的速度有关。对于一般磁盘，m=0.2；对于高速磁盘，m≤0.1，磁臂的启动时间约为2 ms。这样，对于一般的温盘，其寻道时间将随寻道距离的增加而增大，大体上是5～30 ms。 

　    2)旋转延迟时间T~r~
　　**这是指定扇区移动到磁头下面所经历的时间。**不同的磁盘类型中，旋转速度至少相差一个数量级，如软盘为300 r/min，硬盘一般为7200～15 000 r/min，甚至更高。对于磁盘旋转延迟时间而言，如硬盘，旋转速度为15 000 r/min，每转需时4 ms，平均旋转延迟时间Tr为2 ms；而软盘，其旋转速度为 300 r/min或600 r/min，这样，平均T~r~为50～100 ms。 

这个通常计算平均值 
$$
T_r=\frac{1}{2r}
$$


　   3)传输时间T~t~
　　这是指把数据从磁盘读出或向磁盘写入数据所经历的时间。T~t~的大小与每次所读/写的字节数b和旋转速度有关: 
$$
T_t=\frac{b}{rN}
$$
其中，r为磁盘每秒钟的转数；N为一条磁道上的字节数，当一次读/写的字节数相当于半条磁道上的字节数时，T~t~与T~r~相同。因此，可将访问时间T~a~表示为 
$$
T_a=T_s+T_r+T_t=T_s+\frac{1}{2r}+\frac{b}{rN}
$$
　　由上式可以看出，在访问时间中，寻道时间和旋转延迟时间基本上都与所读/写数据的多少无关，而且它通常占据了访问时间中的大头。例如，我们假定寻道时间和旋转延迟时间平均为20 ms，而磁盘的传输速率为10 MB/s，如果要传输10 KB的数据，此时总的访问时间为21 ms，可见传输时间所占比例是非常小的。当传输100 KB数据时，其访问时间也只是30 ms，即当传输的数据量增大10倍时，访问时间只增加约50%。目前磁盘的传输速率已达80 MB/s以上，数据传输时间所占的比例更低。可见，适当地集中数据(不要太零散)传输，将有利于提高传输效率。 

## T24 目前常用的磁盘调度算法有哪几种？每种算法优先考虑的问题是什么？

- 先来先服务调度算法（FCFS）
  - 考虑进程请求访问磁盘的先后次序
- 最短寻道时间优先算法（SSTF）
  - 优先考虑的请求是要求访问的磁道与当前磁头所在的磁道距离最短
- 扫描调度算法（SCAN）
  - 不仅考虑的请求要求访问的磁道与当前磁头所在的磁道距离，还考虑磁头移动的方向
- 循环扫描算法调度算法（CSCAN）
  - 磁头单向移动
- N-step-SCAN 和 FSCAN 调度算法
  - 简化

## T27 何谓提前读、延迟写和虚拟盘？

#### 　　1．提前读(Read-ahead)

　　用户(进程)对文件进行访问时，经常采用顺序访问方式，即顺序地访问文件各盘块的数据。在这种情况下，在读当前块时可以预知下一次要读的盘块。因此，可以采取预先读方式，**即在读当前块的同时，还要求将下一个盘块(提前读的块)中的数据也读入缓冲区。**这样，当下一次要读该盘块中的数据时，由于该数据已被提前读入缓冲区，因而此时便可直接从缓冲区中取得下一盘块的数据，而不需再去启动磁盘I/O，从而大大减少了读数据的时间。这也就等效于提高了磁盘I/O的速度。“提前读”功能已被广泛采用，如在UNIX系统、OS/2，以及在3 Plus和Netware等的网络OS中，都已采用该功能。 

#### 　　2．延迟写

　　**延迟写是指在缓冲区 A 中的数据，本应立即写回磁盘，但考虑到该缓冲区中的数据在不久之后可能还会再被本进程或其它进程访问(共享资源)，因而并不立即将该缓冲区 A 中的数据写入磁盘，而是将它挂在空闲缓冲区队列的末尾。**随着空闲缓冲区的使用，缓冲区也缓缓往前移动，直至移到空闲缓冲队列之首。当再有进程申请到该缓冲区时，才将该缓冲区中的数据写入磁盘，而把该缓冲区作为空闲缓冲区分配出去。当该缓冲区A仍在队列中时，任何访问该数据的进程，都可直接读出其中的数据而不必去访问磁盘。这样，又可进一步减小等效的磁盘I/O时间。同样，“延迟写”功能已在UNIX系统、OS/2等OS中被广泛采用。 

#### 　　3．优化物理块的分布

　　另一种提高磁盘I/O速度的重要措施是优化文件物理块的分布，使磁头的移动距离最小。虽然链接分配和索引分配方式都允许将一个文件的物理块分散在磁盘的任意位置，但如果将一个文件的多个物理块安排得过于分散，会增加磁头的移动距离。例如，将文件的第一个盘块安排在最里的一条磁道上，而把第二个盘块安排在最外的一条磁道上，这样，在读完第一个盘块后转去读第二个盘块时，磁头要从最里的磁道移到最外的磁道上。如果我们将这两个数据块安排在属于同一条磁道的两个盘块上，显然会由于消除了磁头在磁道间的移动，而大大提高对这两个盘块的访问速度。 

　　对文件盘块位置的优化，应在为文件分配盘块时进行。如果系统中的空白存储空间是采用位示图方式表示的，则要将同属于一个文件的盘块安排在同一条磁道上或相邻的磁道上是十分容易的事。这时，只要从位示图中找到一片相邻接的多个空闲盘块即可。但当系统采用线性表(链)法来组织空闲存储空间时，要为一文件分配多个相邻接的盘块，就要困难一些。此时，我们可以将在同一条磁道上的若干个盘块组成一簇，例如，一簇包括4个盘块，在分配存储空间时，以簇为单位进行分配。这样就可以保证在访问这几个盘块时，不必移动磁头或者仅移动一条磁道的距离，从而减少了磁头的平均移动距离。 

#### 　　4．虚拟盘

　　**所谓虚拟盘，是指利用内存空间去仿真磁盘，又称为RAM盘。**该盘的设备驱动程序也可以接受所有标准的磁盘操作，但这些操作的执行，不是在磁盘上而是在内存中。这些对用户都是透明的。换言之，用户并不会发现这与真正的磁盘操作有什么不同，而仅仅是略微快些而已。虚拟盘的主要问题是：它是易失性存储器，故一旦系统或电源发生故障，或系统再启动时，原来保存在虚拟盘中的数据将会丢失。因此，虚拟盘通常用于存放临时文件，如编译程序所产生的目标程序等。虚拟盘与磁盘高速缓存的主要区别在于: 虚拟盘中的内容完全由用户控制，而高速磁盘缓存中的内容则是由OS控制的。例如，RAM盘在开始时是空的，仅当用户(程序)在RAM盘中创建了文件后，RAM盘中才有内容。 
