## 2.1 进程的基本概念

### 2.1.1程序的顺序执行及其特征

#### 1. 程序的顺序执行

可以把一个应用程序分成若干个程序段，在各程序段之间，必须按照某种先后次序顺序执行。仅当，前一操作(程序段)执行完后，才能执行后继操作。例如，在进行计算时，总须先输入用户的程序和数据，然后进行计算，最后才能打印计算结果。这里，我们用结点(Node)代表各程序段的操作(在图2-1中用圆圈表示)，其中，I代表输入操作，C代表计算操作，P为打印操作；另外，用箭头指示操作的先后次序。这样，上述的三个程序段的执行顺序可示于图2-1(a)中。对一个程序段中的多条语句来说，也有一个执行顺序问题，例如对于下述三条语句的程序段: 

```
S1: a:=x+y；
S2: b:=a-5；
S3: c:=b+1；
```

其中，语句S2必须在语句S1之后(即a被赋值)才能执行；

同样，语句S3也只能在b被赋值后才能执行。因此，这三条语句应按图2-1(b)所示的顺序执行。

![2-1](https://images-1302683597.cos.ap-nanjing.myqcloud.com/images/StudyNotes/OperatringSystem/2/images_20220330001839.svg)

#### 　2. 程序顺序执行时的特征
　　(1) 顺序性：处理机的操作严格按照程序所规定的顺序执行，即每一操作必须在上一个操作结束之后开始。
　　(2) 封闭性：程序是在封闭的环境下执行的，即程序运行时独占全机资源，资源的状态(除初始状态外)只有本程序才能改变它。程序一旦开始执行，其执行结果不受外界因素影响。
　　(3) 可再现性：只要程序执行时的环境和初始条件相同，当程序重复执行时，不论它是从头到尾不停顿地执行，还是“停停走走”地执行，都将获得相同的结果。
　　程序顺序执行时的特性，为程序员检测和校正程序的错误带来了很大的方便。 

### 2.1.2　前趋图
　　前趋图(Precedence Graph)是一个有向无循环图，记为DAG(Directed Acyclic Graph)，用于描述进程之间执行的前后关系。图中的每个结点可用于描述一个程序段或进程，乃至一条语句；结点间的有向边则用于表示两个结点之间存在的偏序(Partial Order，亦称偏序关系)或前趋关系(Precedence Relation)“→”。

　　$→={(P_i，P_j)|\text{Pi must complete before Pj may start} }$，如果(Pi，Pj)∈→，可写成Pi→Pj，称Pi是Pj的直接前趋，而称Pj是Pi的直接后继。在前趋图中，把没有前趋的结点称为初始结点(Initial Node)，把没有后继的结点称为终止结点(Final Node)。此外，每个结点还具有一个重量(Weight)，用于表示该结点所含有的程序量或结点的执行时间。在图2-1(a)和2-1(b)中分别存在着这样的前趋关系： 

$I_i→C_i→P_i$ 

和

$S_1→S_2→S_3 $

对于图2-2(a)所示的前趋图，存在下述前趋关系： 

```
　　P1→P2，P1→P3，P1→P4，P2→P5，P3→P5，P4→P6，P4→P7，P5→P8，P6→P8，P7→P9，P8→P9
```

或表示为：

```
　　P={P1，P2，P3，P4，P5，P6，P7，P8，P9}
→={(P1，P2)，(P1，P3)，(P1，P4)，(P2，P5)，(P3，P5)，(P4，P6)，(P4，P7)，(P5，P8)，(P6，P8)，(P7，P9)，(P8，P9)} 

```

应当注意，前趋图中必须不存在循环，但在图2-2(b)中却有着下述的前趋关系： 

```
S2→S3，S3→S2 
```

![2-2](https://images-1302683597.cos.ap-nanjing.myqcloud.com/images/StudyNotes/OperatringSystem/2/images_20220330001849.svg)

### 2.1.3　程序的并发执行及其特征
#### 1．程序的并发执行
　　在图2-1中的输入程序、计算程序和打印程序三者之间，存在着Ii→Ci→Pi这样的前趋关系，以至对一个作业的输入、计算和打印三个操作，必须顺序执行，但并不存在Pi→Ii+1的关系，因而在对一批程序进行处理时，可使它们并发执行。例如，输入程序在输入第一个程序后，在计算程序对该程序进行计算的同时，可由输入程序再输入第二个程序，从而使第一个程序的计算操作可与第二个程序的输入操作并发执行。一般来说，输入程序在输入第i+1个程序时，计算程序可能正在对第i个程序进行计算，而打印程序正在打印第i-1个程序的计算结果。图2-3示出了输入、计算和打印这三个程序对一批作业进行处理的情况。 

![2-3](https://images-1302683597.cos.ap-nanjing.myqcloud.com/images/StudyNotes/OperatringSystem/2/images_20220330001858.svg)

在该例中存在下述前趋关系： 

Ii→Ci，Ii→Ii+1，Ci→Pi，Ci→Ci+1，Pi→Pi+1

而Ii+1和Ci及Pi-1是重迭的，亦即在Pi-1和Ci以及Ii+1之间，可以并发执行。对于具有下述四条语句的程序段：

S1: a:=x+2

S2: b:=y+4

S3: c:=a+b

S4: d:=c+b 

![ 2-4](https://images-1302683597.cos.ap-nanjing.myqcloud.com/images/StudyNotes/OperatringSystem/2/images_20220330001906.svg)

#### 2．程序并发执行时的特征
　　1) 间断性
　　程序在并发执行时，由于它们共享系统资源，以及为完成同一项任务而相互合作，致使在这些并发执行的程序之间，形成了相互制约的关系。例如，图2-3 中的I、C和P是三个相互合作的程序，当计算程序完成Ci－1的计算后，如果输入程序I尚未完成Ii的处理，则计算程序就无法进行Ci的处理，致使计算程序必须暂停运行。又如，当打印程序完成Pi的打印后，若计算程序尚未完成Ci＋1的计算，则打印程序就无法对Ci＋1的计算结果进行打印。一旦使程序暂停的因素消失后(如Ii已处理完成)，计算程序便可恢复执行对Ci的处理。简而言之，相互制约将导致并发程序具有“执行—暂停—执行”这种间断性的活动规律。 

　　2) 失去封闭性
　　程序在并发执行时，是多个程序共享系统中的各种资源，因而这些资源的状态将由多个程序来改变，致使程序的运行失去了封闭性。这样，某程序在执行时，必然会受到其它程序的影响。例如，当处理机这一资源已被某个程序占有时，另一程序必须等待。 

　　3) 不可再现性
　　程序在并发执行时，由于失去了封闭性，也将导致其再失去可再现性。例如，有两个循环程序A和B，它们共享一个变量N。程序A每执行一次时，都要做N:=N+1操作；程序B每执行一次时，都要执行Print(N)操作，然后再将N置成“0”。程序A和B以不同的速度运行。这样，可能出现下述三种情况(假定某时刻变量N的值为n)。 

　　(1) N:=N+1在Print(N)和N:=0之前，此时得到的N值分别为n+1，n+1，0。

　　(2) N:=N+1在Print(N)和N:=0之后，此时得到的N值分别为n，0，1。

　　(3) N:=N+1在Print(N)和N:=0之间，此时得到的N值分别为n，n+1，0。

　　上述情况说明，程序在并发执行时，由于失去了封闭性，其计算结果与已并发程序的执行速度有关，从而使程序的执行失去了可再现性，亦即，程序经过多次执行后，虽然它们执行时的环境和初始条件相同，但得到的结果却各不相同。 

### 2.1.4　进程的特征与状态

#### 1. 进程的特征和定义

　　在多道程序环境下，程序的执行属于并发执行，此时它们将失去其封闭性，并具有间断性及不可再现性的特征。这决定了通常的程序是不能参与并发执行的，因为程序执行的结果是不可再现的。这样，程序的运行也就失去了意义。为使程序能并发执行，且为了对并发执行的程序加以描述和控制，人们引入了“进程”的概念。为了能较深刻地了解什么是进程，我们将先对进程的特征加以描述。 

　　1) 结构特征
　　通常的程序是不能并发执行的。为使程序(含数据)能独立运行，应为之配置一进程控制块，即PCB(Process Control Block)；而由程序段、相关的数据段和PCB三部分便构成了进程实体。在早期的UNIX版本中，把这三部分总称为“进程映像”。值得指出的是，在许多情况下所说的进程，实际上是指进程实体，例如，所谓创建进程，实质上是创建进程实体中的PCB；而撤消进程，实质上是撤消进程的PCB，本教材中也是如此。 
　　2) 动态性
　　进程的实质是进程实体的一次执行过程，因此，动态性是进程的最基本的特征。动态性还表现在：“它由创建而产生，由调度而执行，由撤消而消亡”。可见，进程实体有一定的生命期，而程序则只是一组有序指令的集合，并存放于某种介质上，其本身并不具有运动的含义，因而是静态的。 
　　3) 并发性
　　这是指多个进程实体同存于内存中，且能在一段时间内同时运行。并发性是进程的重要特征，同时也成为OS的重要特征。引入进程的目的也正是为了使其进程实体能和其它进程实体并发执行；而程序(没有建立PCB)是不能并发执行的。
　　4) 独立性
　　在传统的OS中，独立性是指进程实体是一个能独立运行、独立分配资源和独立接受调度的基本单位。凡未建立PCB的程序都不能作为一个独立的单位参与运行。 　　
　　5) 异步性
　　这是指进程按各自独立的、 不可预知的速度向前推进，或说进程实体按异步方式运行。

　　现在我们再来讨论进程的定义。曾有许多人从不同的角度对进程下过定义，其中较典型的进程定义有：
　　(1) 进程是程序的一次执行。
　　(2) 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。
　　(3) 进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。 

#### 2.   进程的三种基本状态

　　进程执行时的间断性决定了进程可能具有多种状态。事实上，运行中的进程可能具有以下三种基本状态。

　　1) 就绪(Ready)状态

　　当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。 

　　2) 执行状态

　　进程已获得CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态； 在多处理机系统中，则有多个进程处于执行状态。

　　3) 阻塞状态

　　正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，亦即进程的执行受到阻塞，把这种暂停状态称为阻塞状态，有时也称为等待状态或封锁状态。致使进程阻塞的典型事件有：请求I/O，申请缓冲空间等。通常将这种处于阻塞状态的进程也排成一个队列。有的系统则根据阻塞原因的不同而把处于阻塞状态的进程排成多个队列。 

![2-5](https://images-1302683597.cos.ap-nanjing.myqcloud.com/images/StudyNotes/OperatringSystem/2/images_20220330001918.svg)

#### 3. 挂起状态

　　 **引入挂起状态的原因**

　　在不少系统中进程只有上述三种状态，但在另一些系统中，又增加了一些新状态，最重要的是挂起状态。引入挂起状态的原因有：

　　(1) 终端用户的请求。当终端用户在自己的程序运行期间发现有可疑问题时，希望暂时使自己的程序静止下来。亦即，使正在执行的进程暂停执行；若此时用户进程正处于就绪状态而未执行，则该进程暂不接受调度，以便用户研究其执行情况或对程序进行修改。我们把这种静止状态称为挂起状态。 　

　　(2) 父进程请求。有时父进程希望挂起自己的某个子进程，以便考查和修改该子进程，或者协调各子进程间的活动。

　　(3) 负荷调节的需要。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统能正常运行。

　　(4) 操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。 

　　 **进程状态的转换**

　　在引入挂起状态后，又将增加从挂起状态(又称为静止状态)到非挂起状态(又称为活动状态)的转换；或者相反。可有以下几种情况：

　　(1) 活动就绪→静止就绪。当进程处于未被挂起的就绪状态时，称此为活动就绪状态，表示为Readya。当用挂起原语Suspend将该进程挂起后，该进程便转变为静止就绪状态，表示为Readys，处于Readys状态的进程不再被调度执行。 

![2-6](https://images-1302683597.cos.ap-nanjing.myqcloud.com/images/StudyNotes/OperatringSystem/2/images_20220330001926.svg)

　　(2) 活动阻塞→静止阻塞。当进程处于未被挂起的阻塞状态时，称它是处于活动阻塞状态，表示为Blockeda。当用Suspend原语将它挂起后，进程便转变为静止阻塞状态，表示为Blockeds。处于该状态的进程在其所期待的事件出现后，将从静止阻塞变为静止就绪。

　　(3) 静止就绪→活动就绪。处于Readys状态的进程，若用激活原语Active激活后，该进程将转变为Readya状态。

　　(4) 静止阻塞→活动阻塞。处于Blockeds状态的进程，若用激活原语Active激活后，该进程将转变为Blockeda状态。图2-6示出了具有挂起状态的进程状态图。

#### 4．创建状态和终止状态

　　1) 创建状态

　　创建一个进程一般要通过两个步骤：首先，为一个新进程创建PCB，并填写必要的管理信息；其次，把该进程转入就绪状态并插入就绪队列之中。当一个新进程被创建时，系统已为其分配了PCB，填写了进程标识等信息，但由于该进程所必需的资源或其它信息，如主存资源尚未分配等，一般而言，此时的进程已拥有了自己的PCB，但进程自身还未进入主存，即创建工作尚未完成，进程还不能被调度运行，其所处的状态就是创建状态。 

　　引入创建状态，是为了保证进程的调度必须在创建工作完成后进行，以确保对进程控制块操作的完整性。同时，创建状态的引入，也增加了管理的灵活性，操作系统可以根据系统性能或主存容量的限制，推迟创建状态进程的提交。对于处于创建状态的进程，获得了其所必需的资源，以及对其PCB初始化工作完成后，进程状态便可由创建状态转入就绪状态。 

　　2) 终止状态

　　进程的终止也要通过两个步骤：首先等待操作系统进行善后处理，然后将其PCB清零，并将PCB空间返还系统。当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结，它将进入终止状态。进入终止态的进程以后不能再执行，但在操作系统中依然保留一个记录，其中保存状态码和一些计时统计数据，供其它进程收集。一旦其它进程完成了对终止状态进程的信息提取之后，操作系统将删除该进程。

　　图2-7示出了增加了创建状态和终止状态后，进程的三种基本状态及转换图衍变为五种状态及转换关系图。

![2-7](https://images-1302683597.cos.ap-nanjing.myqcloud.com/images/StudyNotes/OperatringSystem/2/images_20220330001942.svg) 　

![2-8](https://images-1302683597.cos.ap-nanjing.myqcloud.com/images/StudyNotes/OperatringSystem/2/images_20220330001951.svg)

　　如图2-8所示，引进创建和终止状态后，在进程状态转换时，相比较图2-7所示的进程五状态转换而言，需要增加考虑下面的几种情况。

　　(1) NULL→创建：一个新进程产生时，该进程处于创建状态。

　　(2) 创建→活动就绪：在当前系统的性能和内存的容量均允许的情况下，完成对进程创建的必要操作后，相应的系统进程将进程的状态转换为活动就绪状态。 

　　(3) 创建→静止就绪：考虑到系统当前资源状况和性能要求，并不分配给新建进程所需资源，主要是主存资源，相应的系统进程将进程状态转为静止就绪状态，对换到外存，不再参与调度，此时进程创建工作尚未完成。

　　(4) 执行→终止：当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结，进程即进终止状态。 

### 2.1.5　进程控制块
#### 1．进程控制块的作用
　　为了描述和控制进程的运行，系统为每个进程定义了一个数据结构——进程控制块PCB(Process Control Block)，它是进程实体的一部分，是操作系统中最重要的记录型数据结构。PCB中记录了操作系统所需的、用于描述进程的当前情况以及控制进程运行的全部信息。进程控制块的作用是使一个在多道程序环境下不能独立运行的程序(含数据)，成为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。

　　或者说，OS是根据PCB来对并发执行的进程进行控制和管理的。例如，当OS要调度某进程执行时，要从该进程的PCB中查出其现行状态及优先级；在调度到某进程后，要根据其PCB中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存始址，找到其程序和数据； 进程在执行过程中，当需要和与之合作的进程实现同步、通信或访问文件时，也都需要访问PCB；当进程由于某种原因而暂停执行时，又须将其断点的处理机环境保存在PCB中。可见，在进程的整个生命期中，系统总是通过PCB对进程进行控制的，亦即，系统是根据进程的PCB而不是任何别的什么而感知到该进程的存在的。所以说，PCB是进程存在的惟一标志。 

　　当系统创建一个新进程时，就为它建立了一个PCB；进程结束时又回收其PCB，进程于是也随之消亡。PCB可以被操作系统中的多个模块读或修改，如被调度程序、资源分配程序、中断处理程序以及监督和分析程序等读或修改。因为PCB经常被系统访问，尤其是被运行频率很高的进程及分派程序访问，故PCB应常驻内存。系统将所有的PCB组织成若干个链表(或队列)，存放在操作系统中专门开辟的PCB区内。例如在Linux系统中用task_struct数据结构来描述每个进程的进程控制块，在Windows操作系统中则使用一个执行体进程块(EPROCESS)来表示进程对象的基本属性。 

#### 2．进程控制块中的信息
　　 **进程标识符**
　　进程标识符用于惟一地标识一个进程。一个进程通常有两种标识符：
　　(1) 内部标识符。在所有的操作系统中，都为每一个进程赋予了一个惟一的数字标识符，它通常是一个进程的序号。设置内部标识符主要是为了方便系统使用。
　　(2) 外部标识符。它由创建者提供，通常是由字母、数字组成，往往是由用户(进程)在访问该进程时使用。为了描述进程的家族关系，还应设置父进程标识及子进程标识。此外，还可设置用户标识，以指示拥有该进程的用户。 

　　 **处理机状态**

　　处理机状态信息主要是由处理机的各种寄存器中的内容组成的。处理机在运行时，许多信息都放在寄存器中。当处理机被中断时，所有这些信息都必须保存在PCB中，以便在该进程重新执行时，能从断点继续执行。这些寄存器包括：① 通用寄存器，又称为用户可视寄存器，它们是用户程序可以访问的，用于暂存信息，在大多数处理机中，有 8～32个通用寄存器，在RISC结构的计算机中可超过100个；② 指令计数器，其中存放了要访问的下一条指令的地址；③ 程序状态字PSW，其中含有状态信息，如条件码、执行方式、中断屏蔽标志等；④ 用户栈指针，指每个用户进程都有一个或若干个与之相关的系统栈，用于存放过程和系统调用参数及调用地址，栈指针指向该栈的栈顶。 

　　 **进程调度信息**

　　在PCB中还存放一些与进程调度和进程对换有关的信息，包括：

① 进程状态，指明进程的当前状态，作为进程调度和对换时的依据；

② 进程优先级，用于描述进程使用处理机的优先级别的一个整数，优先级高的进程应优先获得处理机；

③ 进程调度所需的其它信息，它们与所采用的进程调度算法有关，比如，进程已等待CPU的时间总和、进程已执行的时间总和等；

④ 事件，指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因。 

　　 **进程控制信息**

　　进程控制信息包括：

① 程序和数据的地址，指进程的程序和数据所在的内存或外存地(首)址，以便再调度到该进程执行时，能从PCB中找到其程序和数据；

② 进程同步和通信机制，指实现进程同步和进程通信时必需的机制，如消息队列指针、信号量等，它们可能全部或部分地放在PCB中；

③ 资源清单，即一张列出了除CPU以外的、进程所需的全部资源及已经分配到该进程的资源的清单；

④ 链接指针，它给出了本进程(PCB)所在队列中的下一个进程的PCB的首地址。　　

#### 3. 进程控制块的组织方式

　　1) 链接方式

　　这是把具有同一状态的PCB，用其中的链接字链接成一个队列。这样，可以形成就绪队列、若干个阻塞队列和空白队列等。对其中的就绪队列常按进程优先级的高低排列，把优先级高的进程的PCB排在队列前面。此外，也可根据阻塞原因的不同而把处于阻塞状态的进程的PCB排成等待I/O操作完成的队列和等待分配内存的队列等。图2-9示出了一种链接队列的组织方式。

![2-9](https://images-1302683597.cos.ap-nanjing.myqcloud.com/images/StudyNotes/OperatringSystem/2/images_20220330002001.svg)

　　2) 索引方式　

　　系统根据所有进程的状态建立几张索引表。例如，就绪索引表、阻塞索引表等，并把各索引表在内存的首地址记录在内存的一些专用单元中。在每个索引表的表目中，记录具有相应状态的某个 PCB 在 PCB 表中的地址。图2-10示出了索引方式的PCB组织。 

![2-10](https://images-1302683597.cos.ap-nanjing.myqcloud.com/images/StudyNotes/OperatringSystem/2/images_20220330002007.svg)

## 2.1 进程控制

　　进程控制是进程管理中最基本的功能。它用于创建一个新进程，终止一个已完成的进程，或终止一个因出现某事件而使其无法运行下去的进程，还可负责进程运行中的状态转换。如当一个正在执行的进程因等待某事件而暂时不能继续执行时，将其转换为阻塞状态，而当该进程所期待的事件出现时，又将该进程转换为就绪状态等等。进程控制一般是由OS的内核中的原语来实现的。 

　　原语(Primitive)是由若干条指令组成的，用于完成一定功能的一个过程。它与一般过程的区别在于：它们是“原子操作(Action Operation)”。所谓原子操作，是指一个操作中的所有动作要么全做，要么全不做。换言之，它是一个不可分割的基本单位，因此，在执行过程中不允许被中断。原子操作在管态下执行，常驻内存。 

![2-11](https://images-1302683597.cos.ap-nanjing.myqcloud.com/images/StudyNotes/OperatringSystem/2/images_20220330002016.svg)

### 2.2.1　进程的创建

#### 1．进程图(Process Graph)

　　进程图是用于描述一个进程的家族关系的有向树，如图2-11所示。图中的结点(圆圈)代表进程。在进程D创建了进程I之后，称D是I的父进程(Parent Process)，I是D的子进程(Progeny Process)。 

#### 2．引起创建进程的事件
　　在多道程序环境中，只有(作为)进程(时)才能在系统中运行。因此，为使程序能运行，就必须为它创建进程。导致一个进程去创建另一个进程的典型事件，可有以下四类：
　　(1) 用户登录。在分时系统中，用户在终端键入登录命令后，如果是合法用户，系统将为该终端建立一个进程，并把它插入就绪队列中。

　　(2) 作业调度。在批处理系统中，当作业调度程序按一定的算法调度到某作业时，便将该作业装入内存，为它分配必要的资源，并立即为它创建进程，再插入就绪队列中。 　　

　　(3) 提供服务。当运行中的用户程序提出某种请求后，系统将专门创建一个进程来提供用户所需要的服务，例如，用户程序要求进行文件打印，操作系统将为它创建一个打印进程，这样，不仅可使打印进程与该用户进程并发执行，而且还便于计算出为完成打印任务所花费的时间。 

　　(4) 应用请求。在上述三种情况下，都是由系统内核为它创建一个新进程；而第4类事件则是基于应用进程的需求，由它自己创建一个新进程，以便使新进程以并发运行方式完成特定任务。例如，某应用程序需要不断地从键盘终端输入数据，继而又要对输入数据进行相应的处理，然后，再将处理结果以表格形式在屏幕上显示。该应用进程为使这几个操作能并发执行，以加速任务的完成，可以分别建立键盘输入进程、表格输出进程。 

#### 3．进程的创建(Creation of Process)
　　一旦操作系统发现了要求创建新进程的事件后，便调用进程创建原语Creat( )按下述步骤创建一个新进程。

　　(1) 申请空白PCB。为新进程申请获得惟一的数字标识符，并从PCB集合中索取一个空白PCB。

　　(2) 为新进程分配资源。为新进程的程序和数据以及用户栈分配必要的内存空间。显然，此时操作系统必须知道新进程所需内存的大小。对于批处理作业，其大小可在用户提出创建进程要求时提供。若是为应用进程创建子进程，也应是在该进程提出创建进程的请求中给出所需内存的大小。对于交互型作业，用户可以不给出内存要求而由系统分配一定的空间。如果新进程要共享某个已在内存的地址空间(即已装入内存的共享段)，则必须建立相应的链接。

　　(3) 初始化进程控制块。PCB的初始化包括：

① 初始化标识信息，将系统分配的标识符和父进程标识符填入新PCB中；

② 初始化处理机状态信息，使程序计数器指向程序的入口地址，使栈指针指向栈顶；

③ 初始化处理机控制信息，将进程的状态设置为就绪状态或静止就绪状态，对于优先级，通常是将它设置为最低优先级，除非用户以显式方式提出高优先级要求。

　　(4) 将新进程插入就绪队列，如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。

### 2.2.2　进程的终止
#### 1．引起进程终止的事件
　　**1) 正常结束**
　　在任何计算机系统中，都应有一个用于表示进程已经运行完成的指示。例如，在批处理系统中，通常在程序的最后安排一条Holt指令或终止的系统调用。当程序运行到Holt指令时，将产生一个中断，去通知OS本进程已经完成。在分时系统中，用户可利用Logs off去表示进程运行完毕，此时同样可产生一个中断，去通知OS进程已运行完毕。 

　　**2) 异常结束**

　　在进程运行期间，由于出现某些错误和故障而迫使进程终止(Termination of Process)。这类异常事件很多，常见的有下述几种：

　　(1) 越界错误。这是指程序所访问的存储区已越出该进程的区域。

　　(2) 保护错误。这是指进程试图去访问一个不允许访问的资源或文件，或者以不适当的方式进行访问，例如，进程试图去写一个只读文件。

　　(3) 非法指令。这是指程序试图去执行一条不存在的指令。出现该错误的原因，可能是程序错误地转移到数据区，把数据当成了指令。

　　(4) 特权指令错。这是指用户进程试图去执行一条只允许OS执行的指令。

　　(5) 运行超时。这是指进程的执行时间超过了指定的最大值。

　　(6) 等待超时。这是指进程等待某事件的时间超过了规定的最大值。

　　(7) 算术运算错。这是指进程试图去执行一个被禁止的运算，例如被0除。

　　(8) I/O故障。这是指在I/O过程中发生了错误等。 

　　**3) 外界干预**

　　外界干预并非指在本进程运行中出现了异常事件，而是指进程应外界的请求而终止运行。这些干预有：

　　(1) 操作员或操作系统干预。由于某种原因，例如，发生了死锁，由操作员或操作系统终止该进程。

　　(2) 父进程请求。由于父进程具有终止自己的任何子孙进程的权力，因而当父进程提出请求时，系统将终止该进程。

　　(3) 父进程终止。当父进程终止时，OS也将它的所有子孙进程终止。 

#### 2．进程的终止过程
　　如果系统中发生了上述要求终止进程的某事件，OS便调用进程终止原语，按下述过程去终止指定的进程。

　　(1) 根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态。

　　(2) 若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度。 

　　(3) 若该进程还有子孙进程，还应将其所有子孙进程予以终止，以防它们成为不可控的进程。

　　(4) 将被终止进程所拥有的全部资源，或者归还给其父进程，或者归还给系统。

　　(5) 将被终止进程(PCB)从所在队列(或链表)中移出，等待其他程序来搜集信息。 

### 2.2.3　进程的阻塞与唤醒
#### 1. 引起进程阻塞和唤醒的事件
　　有下述几类事件会引起进程阻塞或被唤醒。
　　1) 请求系统服务
　　当正在执行的进程请求操作系统提供服务时，由于某种原因，操作系统并不立即满足该进程的要求时，该进程只能转变为阻塞状态来等待。例如，一进程请求使用某资源，如打印机，由于系统已将打印机分配给其他进程而不能分配给请求进程，这时请求者进程只能被阻塞，仅在其他进程在释放出打印机的同时，才将请求进程唤醒。 

　　2) 启动某种操作

　　当进程启动某种操作后，如果该进程必须在该操作完成之后才能继续执行，则必须先使该进程阻塞，以等待该操作完成。例如，进程启动了某I/O设备，如果只有在I/O设备完成了指定的I/O操作任务后进程才能继续执行，则该进程在启动了I/O操作后，便自动进入阻塞状态去等待。在I/O操作完成后，再由中断处理程序或中断进程将该进程唤醒。 

　　3) 新数据尚未到达

　　对于相互合作的进程，如果其中一个进程需要先获得另一(合作)进程提供的数据后才能对数据进行处理，则只要其所需数据尚未到达，该进程只有(等待)阻塞。例如，有两个进程，进程A用于输入数据，进程B对输入数据进行加工。假如A尚未将数据输入完毕，则进程B将因没有所需的处理数据而阻塞；一旦进程A把数据输入完毕，便可去唤醒进程B。

　　4) 无新工作可做

　　系统往往设置一些具有某特定功能的系统进程，每当这种进程完成任务后，便把自己阻塞起来以等待新任务到来。例如，系统中的发送进程，其主要工作是发送数据，若已有的数据已全部发送完成而又无新的发送请求，这时(发送)进程将使自己进入阻塞状态； 仅当又有进程提出新的发送请求时，才将发送进程唤醒。 

#### 2．进程阻塞过程
　　正在执行的进程，当发现上述某事件时，由于无法继续执行，于是进程便通过调用阻塞原语block把自己阻塞。可见，进程的阻塞是进程自身的一种主动行为。进入block过程后，由于此时该进程还处于执行状态，所以应先立即停止执行，把进程控制块中的现行状态由“执行”改为“阻塞”，并将PCB插入阻塞队列。如果系统中设置了因不同事件而阻塞的多个阻塞队列，则应将本进程插入到具有相同事件的阻塞(等待)队列。最后，转调度程序进行重新调度，将处理机分配给另一就绪进程并进行切换，亦即，保留被阻塞进程的处理机状态(在PCB中)，再按新进程的PCB中的处理机状态设置CPU的环境。 

#### 3．进程唤醒过程

　　当被阻塞进程所期待的事件出现时，如I/O完成或其所期待的数据已经到达，则由有关进程(比如用完并释放了该I/O设备的进程)调用唤醒原语wakeup( )，将等待该事件的进程唤醒。唤醒原语执行的过程是：首先把被阻塞的进程从等待该事件的阻塞队列中移出，将其PCB中的现行状态由阻塞改为就绪，然后再将该PCB插入到就绪队列中。
　　应当指出，block原语和wakeup原语是一对作用刚好相反的原语。因此，如果在某进程中调用了阻塞原语，则必须在与之相合作的另一进程中或其他相关的进程中安排唤醒原语，以能唤醒阻塞进程；否则，被阻塞进程将会因不能被唤醒而长久地处于阻塞状态，从而再无机会继续运行。 

### 2.2.4　进程的挂起与激活
#### 1．进程的挂起
　　当出现了引起进程挂起的事件时，比如，用户进程请求将自己挂起，或父进程请求将自己的某个子进程挂起，系统将利用挂起原语suspend( )将指定进程或处于阻塞状态的进程挂起。挂起原语的执行过程是：首先检查被挂起进程的状态，若处于活动就绪状态，便将其改为静止就绪； 对于活动阻塞状态的进程，则将之改为静止阻塞。为了方便用户或父进程考查该进程的运行情况而把该进程的PCB复制到某指定的内存区域。最后，若被挂起的进程正在执行，则转向调度程序重新调度。 

#### 2．进程的激活过程

　　当发生激活进程的事件时，例如，父进程或用户进程请求激活指定进程，若该进程驻留在外存而内存中已有足够的空间时，则可将在外存上处于静止就绪状态的该进程换入内存。这时，系统将利用激活原语active( )将指定进程激活。激活原语先将进程从外存调入内存，检查该进程的现行状态，若是静止就绪，便将之改为活动就绪；若为静止阻塞，便将之改为活动阻塞。假如采用的是抢占调度策略，则每当有新进程进入就绪队列时，应检查是否要进行重新调度，即由调度程序将被激活进程与当前进程进行优先级的比较，如果被激活进程的优先级更低，就不必重新调度；否则，立即剥夺当前进程的运行，把处理机分配给刚被激活的进程。 

## 2.3  进程的同步
### 2.3.1 进程同步的基本概念
#### 1. 两种形式的制约关系
　　在多道程序环境下，当程序并发执行时，由于资源共享和进程合作，使同处于一个系统中的诸进程之间可能存在着以下两种形式的制约关系。

　　(1) 间接相互制约关系。同处于一个系统中的进程，通常都共享着某种系统资源，如共享CPU、共享I/O设备等。所谓间接相互制约即源于这种资源共享，例如，有两个进程A和B，如果在A进程提出打印请求时，系统已将惟一的一台打印机分配给了进程B，则此时进程A只能阻塞；一旦进程B将打印机释放，则A进程才能由阻塞改为就绪状态。 

　　(2) 直接相互制约关系。这种制约主要源于进程间的合作。例如，有一输入进程A通过单缓冲向进程B提供数据。当该缓冲空时，计算进程因不能获得所需数据而阻塞，而当进程A把数据输入缓冲区后，便将进程B唤醒；反之，当缓冲区已满时，进程A因不能再向缓冲区投放数据而阻塞，当进程B将缓冲区数据取走后便可唤醒A。

#### 2. 临界资源
　　在第一章中我们曾经介绍过，许多硬件资源如打印机、磁带机等，都属于临界资源(Critical Resouce)，诸进程间应采取互斥方式，实现对这种资源的共享。下面我们将通过一个简单的例子来说明这一过程。 

　　生产者-消费者(producer-consumer)问题是一个著名的进程同步问题。它描述的是：有一群生产者进程在生产产品，并将这些产品提供给消费者进程去消费。为使生产者进程与消费者进程能并发执行，在两者之间设置了一个具有n个缓冲区的缓冲池，生产者进程将它所生产的产品放入一个缓冲区中；消费者进程可从一个缓冲区中取走产品去消费。尽管所有的生产者进程和消费者进程都是以异步方式运行的，但它们之间必须保持同步，即不允许消费者进程到一个空缓冲区去取产品，也不允许生产者进程向一个已装满产品且尚未被取走的缓冲区中投放产品。 

　　我们可利用一个数组来表示上述的具有n个(0，1，…，n-1)缓冲区的缓冲池。用输入指针in来指示下一个可投放产品的缓冲区，每当生产者进程生产并投放一个产品后，输入指针加1；用一个输出指针out来指示下一个可从中获取产品的缓冲区，每当消费者进程取走一个产品后，输出指针加1。由于这里的缓冲池是组织成循环缓冲的，故应把输入指针加1表示成 in:= (in+1)mod n； 输出指针加1表示成out:= (out+1) mod n。当 (in+1) mod n=out时表示缓冲池满；而in=out则表示缓冲池空。此外，还引入了一个整型变量counter，其初始值为0。每当生产者进程向缓冲池中投放一个产品后，使counter加1；反之，每当消费者进程从中取走一个产品时，使counter减1。生产者和消费者两进程共享下面的变量： 

```
Var n，integer；
type item=…；
var buffer: array［0，1，…，n-1］ of item；
in，out: 0，1，…，n-1；
counter: 0，1，…，n； 
```

　　指针in和out初始化为1。在生产者和消费者进程的描述中，noop是一条空操作指令，while condition do no-op语句表示重复的测试条件(condication)，重复测试应进行到该条件变为false(假)，即到该条件不成立时为止。在生产者进程中使用一局部变量nextp，用于暂时存放每次刚生产出来的产品；而在消费者进程中，则使用一个局部变量nextc，用于存放每次要消费的产品。 

```
producer: repeat
　　　　　  
produce an item in nextp；
　　　　　...
while counter=n do no-op；
buffer［in］:=nextp；
in:=in+1 mod n；
counter:=counter+1；
until false； 
consumer: repeat
　   　　　while counter=0 do no-op；
　　　　　nextc:=buffer［out］；
　　　　　out:=(out+1) mod n；
　　　　　counter:=counter-1；
　　　　　consumer the item in nextc；
　　　　    until false； 
```

 　虽然上面的生产者程序和消费者程序在分别看时都是正确的，而且两者在顺序执行时其结果也会是正确的，但若并发执行时就会出现差错，问题就在于这两个进程共享变量counter。生产者对它做加1操作，消费者对它做减1操作，这两个操作在用机器语言实现时， 常可用下面的形式描述： 

```
register1:=counter；     　register2:=counter；
register1:=register1+1；　register2:=register2-1；
counter:=register1；     　counter:=register2； 
```

　　假设counter的当前值是5。如果生产者进程先执行左列的三条机器语言语句，然后消费者进程再执行右列的三条语句，则最后共享变量counter的值仍为5； 反之，如果让消费者进程先执行右列的三条语句，然后再让生产者进程执行左列的三条语句，则counter值也还是5，但是，如果按下述顺序执行：

```
register1:=counter；       	(register1=5)
register1:=register1+1；   	(register1=6)
register2:=counter；       	(register2=5)
register2:=register2-1；    	(register2=4)
counter:=register1；      	(counter=6)
counter:=register2；      	(counter=4) 
```

　　正确的counter值应当是5，但现在是4。读者可以自己试试，倘若再将两段程序中各语句交叉执行的顺序改变，将可看到又可能得到counter=6的答案，这表明程序的执行已经失去了再现性。为了预防产生这种错误，解决此问题的关键是应把变量counter作为临界资源处理，**亦即，令生产者进程和消费者进程互斥地访问变量counter。** 

#### 3．临界区

　　由前所述可知，不论是硬件临界资源，还是软件临界资源，多个进程必须互斥地对它进行访问。人们把在每个进程中访问临界资源的那段代码称为**临界区(critical section)**。显然，若能保证诸进程互斥地进入自己的临界区，便可实现诸进程对临界资源的互斥访问。为此，每个进程在进入临界区之前，应先对欲访问的临界资源进行检查，看它是否正被访问。如果此刻该临界资源未被访问，进程便可进入临界区对该资源进行访问，并设置它正被访问的标志；如果此刻该临界资源正被某进程访问，则本进程不能进入临界区。因此，必须在临界区前面增加一段用于进行上述检查的代码，把这段代码称为进入区(entry section)。相应地，在临界区后面也要加上一段称为退出区(exit section)的代码，用于将临界区正被访问的标志恢复为未被访问的标志。

　　进程中除上述进入区、临界区及退出区之外的其它部分的代码，在这里都称为剩余区。这样，可把一个访问临界资源的循环进程描述如下：

```
　　repeat

　　　　entry section

　　　　critical section；

　　　　exit section

　　　　remainder section；

　　until false； 
```


#### 4．同步机制应遵循的规则

　　**为实现进程互斥地进入自已的临界区**，可用软件方法，更多的是在系统中设置专门的同步机构来协调各进程间的运行。所有同步机制都应遵循下述四条准则：
　　
　　(1) **空闲让进**。当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源。

　　(2) **忙则等待**。当已有进程进入临界区时，表明临界资源正在被访问，因而其它试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。

　　(3) **有限等待**。对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态。

　　(4) **让权等待**。当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态。 　

## 2.3.2　信号量机制

#### 1．整型信号量

　　最初由Dijkstra把**整型信号量定义为一个用于表示资源数目的整型量S**，它与一般整型量不同，除初始化外，仅能通过两个标准的原子操作(Atomic Operation) wait(S)和signal(S)来访问。很长时间以来，这两个操作一直被分别称为P、V操作。Wait(S)和signal(S)操作可描述为：

```
　　wait(S)： while  S<=0 do no-op；

　　　　　　　　 S:=S-1；

　　signal(S)： S:=S+1；
```

　　wait(S)和signal(S)是两个原子操作，因此，它们在执行时是不可中断的。亦即，当一个进程在修改某信号量时，没有其他进程可同时对该信号量进行修改。此外，在wait操作中，对S值的测试和做S:=S-1操作时都不可中断。

#### 2．记录型信号量

　　在整型信号量机制中的wait操作，只要是信号量S≤0，就会不断地测试。**因此，该机制并未遵循“让权等待”的准则，而是使进程处于“忙等”的状态。记录型信号量机制则是一种不存在“忙等”现象的进程同步机制。**但在采取了“让权等待”的策略后，又会出现多个进程等待访问同一临界资源的情况。

为此，在信号量机制中，

- 除了需要一个用于代表**资源数目**的整型变量 value 外，
- 还应增加一个进程链表指针 L ，用于**链接上述的所有等待进程。**

记录型信号量是由于它采用了记录型的数据结构而得名的。它所包含的上述两个数据项可描述为： 

```
type semaphore=record
　　　　　　　value: integer；
　　　　　　　L: list of process；
　　　　　　　end 
相应地，wait(S)和signal(S)操作可描述为：
　　procedure wait(S)
　　　　　var S：semaphore；
　　　　　begin
　　　　　　S.value:=S.value-1；
　　　　　　if S.value<0 then block(S.L)；
　　　　　end 
procedure signal(S)
　　　　　var S: semaphore；
　　　　　begin
　　　　　　S.value:=S.value+1；
　　　　　　if S.value<=0 then wakeup(S.L)；
　　　　　end 

```

　　在记录型信号量机制中，S.value的初值表示系统中某类资源的数目，因而又称为资源信号量。对它的每次wait操作，意味着进程请求一个单位的该类资源，使系统中可供分配的该类资源数减少一个，因此描述为S.value:=S.value-1；当S.value<0时，表示该类资源已分配完毕，因此进程应调用block原语，进行自我阻塞，放弃处理机，并插入到信号量链表S.L中。可见，该机制遵循了“让权等待”准则。此时S.value的绝对值表示在该信号量链表中已阻塞进程的数目。对信号量的每次signal操作，表示执行进程释放一个单位资源，使系统中可供分配的该类资源数增加一个，故S.value:=S.value+1操作表示资源数目加1。若加1后仍是S.value≤0，则表示在该信号量链表中，仍有等待该资源的进程被阻塞，故还应调用wakeup原语，将S.L链表中的第一个等待进程唤醒。如果S.value的初值为1，表示只允许一个进程访问临界资源，此时的信号量转化为互斥信号量，用于进程互斥。

#### 3．AND型信号量

　　上述的进程互斥问题，是针对各进程之间只共享一个临界资源而言的。在有些应用场合，是一个进程需要先获得两个或更多的共享资源后方能执行其任务。假定现有两个进程A和B，他们都要求访问共享数据D和E。当然，共享数据都应作为临界资源。为此，可为这两个数据**分别设置用于互斥的信号量 Dmutex 和 Emutex**，并令它们的初值都是 1 。相应地，在两个进程中都要包含两个对 Dmutex 和 Emutex 的操作，即 

```
process A:　　　　process B:
wait(Dmutex)；　　wait(Emutex)；
wait(Emutex)；　　wait(Dmutex)； 
```

若进程A和B按下述次序交替执行wait操作：

```
　　process A: wait(Dmutex)； 于是Dmutex=0

　　process B: wait(Emutex)； 于是Emutex=0

　　process A: wait(Emutex)； 于是Emutex=-1 A阻塞

　　process B: wait(Dmutex)； 于是Dmutex=-1 B阻塞 
```

　　最后，进程A和B处于僵持状态。在无外力作用下，两者都将无法从僵持状态中解脱出来。我们称此时的进程A和B已进入死锁状态。显然，**当进程同时要求的共享资源愈多时，发生进程死锁的可能性也就愈大。**

　　AND同步机制的基本思想是：**将进程在整个运行过程中需要的所有资源，一次性全部地分配给进程，待进程使用完后再一起释放**。只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源也不分配给它。亦即，对若干个临界资源的分配，采取原子操作方式：要么把它所请求的资源部分配到进程，要么一个也不分配。由死锁理论可知，这样就可避免上述死锁情况的发生。为此，在wait操作中，增加了一个“AND”条件，故称为AND同步，或称为同时wait操作，即Swait(Simultaneous wait)定义如下:

```
Swait(S1，S2，…，Sn)
　　if Si>=1 and ... and Sn >=1 then
　　　for i:=1 to n do
　　　Si:=Si-1；
　　　endfor
　　else
　　place the process in the waiting queue associated with the first Si found with Si<1，and set the program count of this process to the beginning of 

Swait operation 
　　endif

Ssignal(S1，S2，…，Sn)

for i:=1 to n do
　　Si:=Si+1；

Remove all the process waiting in the queue associated with Si into the ready queue.

endfor； 
```

#### 4．信号量集
　　在记录型信号量机制中，wait(S)或signal(S)操作仅能对信号量施以加1或减1操作，意味着每次只能获得或释放一个单位的临界资源。而当一次需要N个某类临界资源时，便要进行N次 wait(S) 操作，显然这是低效的。此外，在有些情况下，当资源数量低于某一下限值时，便不予以分配。因而，在每次分配之前，都必须测试该资源的数量，看其是否大于其下限值。基于上述两点，可以对AND信号量机制加以扩充，形成一般化的“信号量集”机制。Swait操作可描述如下，其中S为信号量，d为需求值，而t为下限值。 

```
Swait(S1，t1，d1，…，Sn，tn，dn)
　　　　if Si>=t1 and … and Sn>=tn then
　　　　　　for i:=1 to n do
　　　　　　　　Si:=Si-di；
　　　　endfor
　　　else
　　　Place the executing process in the waiting queue of the first Si with Si<ti and set its program counter to the beginning of the Swait Operation. 
	endive
Ssignal(S1，d1，…，Sn，dn)
　　for i:=1 to n do
　　　　Si:=Si+di；
　　Remove all the process waiting in the queue associated with Si into the ready queue
　　endfor； 

```

　　下面我们讨论一般“信号量集”的几种特殊情况：

　　(1) Swait(S，d，d)。此时在信号量集中只有一个信号量S，但允许它每次申请d个资源，当现有资源数少于d时，不予分配。

　　(2) Swait(S，1，1)。此时的信号量集已蜕化为一般的记录型信号量(S>1时)或互斥信号量(S=1时)。

　　(3) Swait(S，1，0)。这是一种很特殊且很有用的信号量操作。当S≥1时，允许多个进程进入某特定区；当S变为0后，将阻止任何进程进入特定区。换言之，它相当于一个可控开关。 

### 2.3.3　信号量的应用

　　#### 1．利用信号量实现进程互斥

　　为使多个进程能互斥地访问某临界资源，只须为该资源设置一互斥信号量 mutex，并设其初始值为 1，然后将各进程访问该资源的临界区 CS 置于 wait(mutex) 和 signal(mutex) 操作之间即可。这样，每个欲访问该临界资源的进程在进入临界区之前，都要先对mutex执行wait操作，若该资源此刻未被访问，本次wait操作必然成功，进程便可进入自己的临界区，这时若再有其他进程也欲进入自己的临界区，此时由于对mutex执行wait操作定会失败，因而该进程阻塞，从而保证了该**临界资源能被互斥地访问**。当访问临界资源的进程退出临界区后，又应对mutex执行signal操作，以便释放该临界资源。利用信号量实现进程互斥的进程可描述如下：

```
Var mutex: semaphore:=1;
　　begin
　　parbegin
　　　　process 1: begin
　　　　　　　　　　　 repeat
　　　　　　　　　　　 　wait(mutex);
　　　　　　　　　　　 　critical section
　　　　　　　　　　　 　signal(mutex);
　　　　　　　　　　　 　remainder seetion
　　　　　　　　　　　 until false;
　　　　　　　　　　 end 
process 2: begin
　　　　　　　　 repeat
　　　　　　　　　　wait(mutex);
　　　　　　　　　　critical section
　　　　　　　　　　signal(mutex);
　　　　　　　　　　remainder section
　　　　　　　　　until false;
　　　　　　　　end
　　　　parend 

```

#### 2．利用信号量实现前趋关系

　　还可利用信号量来描述程序或语句之间的前趋关系。设有两个并发执行的进程P1和P2。P1中有语句S1；P2中有语句S2。我们希望在S1执行后再执行S2。为实现这种前趋关系，我们只须使进程P1和P2共享一个公用信号量S，并赋予其初值为0，将signal(S)操作放在语句S1后面；而在S2语句前面插入wait(S)操作，即

- 在进程P1中，用S1；signal(S)；
- 在进程P2中，用wait(S)；S2； 

　　由于S被初始化为0，这样，若P2先执行必定阻塞，只有在进程P1执行完S1；signal(S)；操作后使S增为1时，P2进程方能执行语句S2成功。同样，我们可以利用信号量，按照语句间的前趋关系(见图2-12)，写出一个更为复杂的可并发执行的程序。

　　图2-12示出了一个前趋图，其中S1，S2，S3，…，S6是最简单的程序段(只有一条语句)。为使各程序段能正确执行，应设置若干个初始值为“0”的信号量。如为保证S1→S2，S1→S3的前趋关系，应分别设置信号量a 和b，同样，为了保证S2→S4，S2→S5，S3→S6，S4→S6和S5→S6，应设置信号量c，d，e，f，g。 

```
Var a,b,c,d,e,f,g：semaphore: =0,0,0,0,0,0,0;
　　begin
　　　parbegin
　　　　begin S1； signal(a)； signal(b)； end；
　　　　begin wait(a)； S2； signal(c)； signal(d)； end；
　　　　begin wait(b)； S3； signal(e)； end；
　　　　begin wait(c)； S4； signal(f)； end；
　　　　begin wait(d)； S5； signal(g)； end；
　　　　begin wait(e)； wait(f)； wait(g)； S6； end；
　　　parend
　　end 
```

![2-12](https://images-1302683597.cos.ap-nanjing.myqcloud.com/images/StudyNotes/OperatringSystem/2/images_20220330002031.svg)

### 2.3.4　管程机制
#### 1．管程的定义
　　系统中的各种硬件资源和软件资源，均可用数据结构抽象地描述其资源特性，即**用少量信息和对该资源所执行的操作来表征该资源，而忽略了它们的内部结构和实现细节**。例如，对一台电传机，可用与分配该资源有关的状态信息( busy 或 free )和对它执行请求与释放的操作，以及等待该资源的进程队列来描述。又如，一个FIFO队列，可用其队长、队首和队尾以及在该队列上执行的一组操作来描述。 

　　利用共享数据结构抽象地表示系统中的共享资源，而把对该共享数据结构实施的操作定义为一组过程，如资源的请求和释放过程 request 和 release。进程对共享资源的申请、释放和其它操作，都是通过这组过程对共享数据结构的操作来实现的，这组过程还可以根据资源的情况，或接受或阻塞进程的访问，确保每次仅有一个进程使用共享资源，这样就可以统一管理对共享资源的所有访问，实现进程互斥。

　　**代表共享资源的数据结构，以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序，共同构成了一个操作系统的资源管理模块**，我们称之为管程。**管程被请求和释放资源的进程所调用。**Hansan为管程所下的定义是：“一个管程定义了一个数据结构和能为并发进程所执行(在该数据结构上)的一组操作，这组操作能同步进程和改变管程中的数据”。

　　由上述的定义可知，管程由四部分组成：

① 管程的名称；

② 局部于管程内部的共享数据结构说明；

③ 对该数据结构进行操作的一组过程；

④ 对局部于管程内部的共享数据设置初始值的语句。

图2-13是一个管程的示意图。

![2-13](https://images-1302683597.cos.ap-nanjing.myqcloud.com/images/StudyNotes/OperatringSystem/2/images_20220330002039.svg)

```
管程的语法描述如下：
　　type  monitor_name = MONITOR；
<共享变量说明>；
define <(能被其他模块引用的)过程名列表>；
use  <(要调用的本模块外定义的)过程名列表>；
procedure <过程名>(<形式参数表>)；
begin
 ...
end; 
 ...
function <函数名>(<形式参数表>)：值类型；
begin
 ...
end；
 ...     
begin
  <管程的局部数据初始化语句序列>；
end 

```

　　需要指出的是，局部于管程内部的数据结构，仅能被局部于管程内部的过程所访问，**任何管程外的过程都不能访问它**；反之，局部于管程内部的过程也**仅能访问管程内的数据结构。**由此可见，**管程相当于围墙，它把共享变量和对它进行操作的若干过程围了起来，所有进程要访问临界资源时，都必须经过管程(相当于通过围墙的门)才能进入，而管程每次只准许一个进程进入管程，从而实现了进程互斥。**

　　管程是一种程序设计语言结构成分，它和信号量有同等的表达能力，从语言的角度看，管程主要有以下特性：

　　(1) 模块化。管程是一个基本程序单位，可以单独编译。

　　(2) 抽象数据类型。管程中不仅有数据，而且有对数据的操作。

　　(3) 信息掩蔽。管程中的数据结构只能被管程中的过程访问，这些过程也是在管程内部定义的，供管程外的进程调用，而管程中的数据结构以及过程(函数)的具体实现外部不可见。

　　**管程和进程不同，主要体现在以下几个方面：**

　　(1) 虽然二者都定义了数据结构，但进程定义的是私有数据结构PCB，管程定义的是公共数据结构，如消息队列等；

　　(2) 二者都存在对各自数据结构上的操作，但进程是由顺序程序执行有关的操作，而管程主要是进行同步操作和初始化操作；

　　(3) 设置进程的目的在于实现系统的并发性，而管程的设置则是解决共享资源的互斥使用问题； 

　　(4) 进程通过调用管程中的过程对共享数据结构实行操作，该过程就如通常的子程序一样被调用，因而管程为被动工作方式，进程则为主动工作方式；

　　(5) 进程之间能并发执行，而管程则不能与其调用者并发；

　　(6) 进程具有动态性，由“创建”而诞生，由“撤销”而消亡，而管程则是操作系统中的一个资源管理模块，供进程调用。

#### 2．条件变量

　　**在利用管程实现进程同步时，必须设置同步工具，如两个同步操作原语 wait 和 signal 。**当某进程通过管程请求获得临界资源而未能满足时，管程便调用wait原语使该进程等待，并将其排在等待队列上，如图2-13 所示。仅当另一进程访问完成并释放该资源之后，管程才又调用signal原语，唤醒等待队列中的队首进程。 

　　但是仅仅有上述的同步工具是不够的。考虑一种情况：当一个进程调用了管程，在管程中时被阻塞或挂起，直到阻塞或挂起的原因解除，而在此期间，如果该进程不释放管程，则其它进程无法进入管程，被迫长时间地等待。为了解决这个问题，引入了条件变量 condition 。通常，一个进程被阻塞或挂起的条件(原因)可有多个，因此在管程中设置了多个条件变量，对这些条件变量的访问，只能在管程中进行。

　　管程中对每个条件变量都须予以说明，其形式为：Var x，y：condition。对条件变量的操作仅仅是wait和signal，因此条件变量也是一种抽象数据类型，每个条件变量保存了一个链表，用于记录因该条件变量而阻塞的所有进程，同时提供的两个操作即可表示为x.wait和x.signal，其含义为：

　　① x.wait：正在调用管程的进程因x条件需要被阻塞或挂起，则调用x.wait将自己插入到x条件的等待队列上，并释放管程，直到x条件变化。此时其它进程可以使用该管程。

　　② x.signal：正在调用管程的进程发现x条件发生了变化，则调用x.signal，重新启动一个因x条件而阻塞或挂起的进程。如果存在多个这样的进程，则选择其中的一个，如果没有，则继续执行原进程，而不产生任何结果。这与信号量机制中的signal操作不同，因为后者总是要执行s:=s+1操作，因而总会改变信号量的状态。

　　如果有进程Q因x条件处于阻塞状态，当正在调用管程的进程P执行了x.signal操作后，进程Q 被重新启动，此时两个进程P和Q，如何确定哪个执行，哪个等待，可采用下述两种方式之一进行处理：

- (1) P等待，直至Q离开管程或等待另一条件。

- (2) Q等待，直至P离开管程或等待另一条件。

　　采用哪种处理方式，当然是各执一词。Hoare 采用了第一种处理方式，而 Hansan 选择了两者的折衷，他规定管程中的过程所执行的 signal 操作是过程体的最后一个操作，于是，进程 P 执行 signal 操作后立即退出管程，因而进程Q马上被恢复执行。


## 2.4　经典进程的同步问题 

### 2.4.1　生产者—消费者问题
　　#### 1．利用记录型信号量解决生产者—消费者问题
　　假定在生产者和消费者之间的公用缓冲池中，具有n个缓冲区，这时可利用互斥信号量mutex实现诸进程对缓冲池的互斥使用。利用信号量empty和full分别表示缓冲池中空缓冲区和满缓冲区的数量。又假定这些生产者和消费者相互等效，只要缓冲池未满，生产者便可将消息送入缓冲池；只要缓冲池未空，消费者便可从缓冲池中取走一个消息。对生产者—消费者问题可描述如下: 

```
Var mutex，empty，full: semaphore:=1,n,0；
　　buffer:array[0，…，n-1] of item；
　　in，out:  integer:=0，0；
　　begin
　　　parbegin
　　　proceducer:  begin
　　　　　　　　　repeat
　　　　　　　　　　　　　...
　　　　　　　　　producer an item nextp；
　　　　　　　　　　　　　...
　　　　　　　　　wait(empty)； 
		    	wait(mutex)；
　　　　　　　　　buffer(in):=nextp；
　　　　　　　　　in:=(in+1) mod n；
　　　　　　　　　signal(mutex)；
　　　　　　　　　signal(full)；
　　　　　　　　　until false；
　　　　　　　end
　　　consumer:  begin
　　　　　　　　repeat
　　　　　　　　　　wait(full)；
　　　　　　　　　　wait(mutex)；
　　　　　　　　　　nextc:=buffer(out);
				out:=(out+1) mod n；
　　　　　　　　　　　　signal(mutex)；
　　　　　　　　　　　　signal(empty)；
　　　　　　　　　　　　consumer the item in nextc；
　　　　　　　　　　　until false；
　　　　　　　　　　end
　　　　parend
　　end 



```

	在生产者—消费者问题中应注意：首先，在每个程序中用于实现互斥的 wait(mutex) 和 signal(mutex) 必须成对地出现；其次，对资源信号量 empty 和 full 的 wait 和 signal 操作，同样需要成对地出现，但它们分别处于不同的程序中。
	
	例如，wait(empty) 在计算进程中，而 signal(empty) 则在打印进程中，计算进程若因执行 wait(empty) 而阻塞，则以后将由打印进程将它唤醒；最后，在每个程序中的多个 wait 操作顺序不能颠倒，应先执行对资源信号量的 wait 操作，然后再执行对互斥信号量的 wait 操作，否则可能引起进程死锁。

#### 2．利用AND信号量解决生产者—消费者问题
 　 对于生产者—消费者问题，也可利用 AND 信号量来解决，即用 Swait(empty，mutex) 来代替 wait(empty) 和 wait(mutex)；用Ssignal(mutex，full)来代替signal(mutex)和signal(full)；用Swait(full，mutex)来代替wait(full)和wait(mutex)，以及用Ssignal(mutex，empty)代替Signal(mutex)和Signal(empty)。利用AND信号量来解决生产者—消费者问题的算法描述如下： 

```
Var mutex，empty，full:  semaphore:=1，n，0；
　　　buffer:array[0，…，n-1] of item；
　　　in out:  integer:=0，0；
　　begin
　　　parbegin
　　　　　producer:  begin
　　　　　　　　　　　　repeat
　　　　　　　　　　　　　
　　　　　　　　　　　　produce an item in nextp；
　　　　　　　　　　　　　
　　　　　　　　　　　　Swait(empty，mutex)；
　　　　　　　　　　　　buffer(in):=nextp；
　　　　　　　　　　　　in:=(in+1)mod n；
　　　　　　　　　　　　Ssignal(mutex，full)；
　　　　　　　　　　　until false；
　　　　　　　　　end 
		consumer:begin
　　　　　　　　　　repeat
　　　　　　　　　　　Swait(full，mutex)；
　　　　　　　　　　　Nextc:=buffer(out)；
　　　　　　　　　　　Out:=(out+1) mod n；
　　　　　　　　　　　Ssignal(mutex，empty)；
　　　　　　　　　　　consumer the item in nextc；
　　　　　　　　　until false；
　　　　　　　end
　　　　　parend
　　end 

```

#### 3．利用管程解决生产者—消费者问题

在利用管程方法来解决生产者—消费者问题时，首先便是为它们建立一个管程，并命名为ProclucerConsumer，或简称为PC。其中包括两个过程：

　　(1) put(item)过程。生产者利用该过程将自己生产的产品投放到缓冲池中，并用整型变量count来表示在缓冲池中已有的产品数目，当count≥n时，表示缓冲池已满，生产者须等待。
　　(2) get(item)过程。消费者利用该过程从缓冲池中取出一个产品，当count≤0时，表示缓冲池中已无可取用的产品，消费者应等待。 

```
PC管程可描述如下：
　　type producer-consumer=monitor
　　　　Var in,out,count:  integer；
　　　　　buffer:  array[0, …, n-1] of item；
　　　　　notfull，notempty:condition；
　　　　　procedure entry put(item)
　　　　　　　begin
　　　　　　　　if count>=n then notfull.wait；
　　　　　　　　　buffer(in):=nextp；
　　　　　　　　　in:=(in+1) mod n；
　　　　　　　　　count:=count+1；
　　　　　　　　　if notempty.queue then notempty.signal；
　　　　　　　　end 
　　　　procedure entry get(item)
　　　　　　　begin
　　　　　　　　if count<=0 then notempty.wait；
　　　　　　　　nextc:=buffer(out)；
　　　　　　　　out:=(out+1) mod n；
　　　　　　　　count:=count-1；
　　　　　　　　if notfull.quene then notfull.signal；
　　　　　　　end
　　　　begin in:=out:=0； 
count:=0 
end 
在利用管程解决生产者—消费者问题时，其中的生产者和消费者可描述为：
　　producer:  begin
　　　　　　　　repeat
　　　　　　　　　produce an item in nextp；
　　　　　　　　　PC.put(item)；
　　　　　　　　until false；
　　　　　　　end
　　consumer:  begin
　　　　　　　　repeat
　　　　　　　　　PC.get(item)；
　　　　　　　　　consume the item in nextc；
　　　　　　　　until false；
　　　　　　　end 
```

### 2.4.2　哲学家进餐问题
#### 1．利用记录型信号量解决哲学家进餐问题
　　经分析可知，放在桌子上的筷子是临界资源，在一段时间内只允许一位哲学家使用。为了实现对筷子的互斥使用，可以用一个信号量表示一只筷子，由这五个信号量构成信号量数组。其描述如下： 

```
Var chopstick: array[0，…，4] of semaphore； 
所有信号量均被初始化为1，第i位哲学家的活动可描述为：
　　repeat
　　　　wait(chopstick[i])；
　　　　wait(chopstick[(i+1)mod 5])；
　　　　　　...
　　　　eat；
　　　　　　...
　　　　signal(chopstick[i])；
　　　　signal(chopstick[(i+1)mod 5])；
　　　　　　...
　　　　think；
　　until false； 

```

   在以上描述中，当哲学家饥饿时，总是先去拿他左边的筷子，即执行wait(chopstick[i])； 成功后，再去拿他右边的筷子，即执行wait(chopstick[(i+1)mod 5])；又成功后便可进餐。进餐完毕，又先放下他左边的筷子，然后再放右边的筷子。虽然，上述解法可保证不会有两个相邻的哲学家同时进餐，但有可能引起死锁。假如五位哲学家同时饥饿而各自拿起左边的筷子时，就会使五个信号量chopstick均为0； 当他们再试图去拿右边的筷子时，都将因无筷子可拿而无限期地等待。对于这样的死锁问题，可采取以下几种解决方法： 

　　(1) 至多只允许有四位哲学家同时去拿左边的筷子，最终能保证至少有一位哲学家能够进餐，并在用毕时能释放出他用过的两只筷子，从而使更多的哲学家能够进餐。

　　(2) 仅当哲学家的左、右两只筷子均可用时，才允许他拿起筷子进餐。

　　(3) 规定奇数号哲学家先拿他左边的筷子，然后再去拿右边的筷子，而偶数号哲学家则相反。按此规定，将是1、2号哲学家竞争1号筷子；3、4号哲学家竞争3号筷子。即五位哲学家都先竞争奇数号筷子，获得后，再去竞争偶数号筷子，最后总会有一位哲学家能获得两只筷子而进餐。

#### 2．利用AND信号量机制解决哲学家进餐问题
在哲学家进餐问题中，要求每个哲学家先获得两个临界资源(筷子)后方能进餐，这在本质上就是前面所介绍的AND同步问题，故用AND信号量机制可获得最简洁的解法。描述如下：

```
Var chopsiick array  of semaphore:=(1,1,1,1,1)；
　　processi
　　　repeat
　　　　　think；
　　　　　Sswait(chopstick[(i+1)mod 5]，chopstick[i])；
　　　　　eat；
　　　　　Ssignat(chopstick[(i+1)mod 5]，chopstick[i])；
　　　until false； 
```

### 2.4.3　读者—写者问题
#### 1．利用记录型信号量解决：读者—写者问题
　　为实现Reader与Writer进程间在读或写时的互斥而设置了一个互斥信号量Wmutex。另外，再设置一个整型变量Readcount表示正在读的进程数目。由于只要有一个Reader进程在读，便不允许Writer进程去写。因此，仅当Readcount=0，表示尚无Reader进程在读时，Reader进程才需要执行Wait(Wmutex)操作。若Wait(Wmutex)操作成功，Reader进程便可去读，相应地，做Readcount+1操作。同理，仅当Reader进程在执行了Readcount减1操作后其值为0时，才须执行signal(Wmutex)操作，以便让Writer进程写。又因为Readcount是一个可被多个Reader进程访问的临界资源，因此，也应该为它设置一个互斥信号量rmutex。 

```
读者—写者问题可描述如下:
　　Var rmutex，wmutex:  semaphore:=1,1；
　　　　Readcount:  integer:=0；
　　　　begin
　　　　parbegin
　　　　　Reader:  begin
　　　　　　　　repeat
　　　　　　　　　wait(rmutex)；
　　　　　　　　　if readcount=0 then wait(wmutex)；
　　　　　　　　　　Readcount:=Readcount+1；
　　　　　　　　　signal(rmutex)； 
 
　　　　　　　　　perform read operation；
　　　　　　　　　　　...
　　　　　　　　　wait(rmutex)；
　　　　　　　　　readcount:=readcount-1；
　　　　　　　　　if readcount=0 then signal(wmutex)；
　　　　　　　　　signal(rmutex)；
　　　　　　　　until false；
　　　　　　　end
　　　　writer:  begin
　　　　　　　　repeat
　　　　　　　　　wait(wmutex)；
　　　　　　　　　perform write operation；
　　　　　　　　　signal(wmutex)；
　　　　　　　　until false；
　　　　　　　end
　　　　parend
　　end 

```

#### 2．利用信号量集机制解决：读者—写者问题

　　这里的读者—写者问题与前面的略有不同，它增加了一个限制，即最多只允许RN个读者同时读。为此，又引入了一个信号量L，并赋予其初值为RN，通过执行wait(L，1，1)操作，来控制读者的数目。每当有一个读者进入时，就要先执行wait(L，1，1)操作，使L的值减1。当有RN个读者进入读后，L便减为0，第RN+1个读者要进入读时，必然会因wait(L，1，1)操作失败而阻塞。对利用信号量集来解决读者—写者问题的描述如下：

```
Var RN integer；
　　　　L，mx: semaphore:=RN,1；
　　　begin
　　　　parbegin
　　　　　reader: begin
　　　　　　　　repeat
　　　　　　　　　Swait(L,1,1)；
　　　　　　　　　Swait(mx,1,0)；
　　　　　　　　　　　
　　　　　　　　　perform read operation；
　　　　　　　　　　　
　　　　　　　　　Ssignal(L,1)；
　　　　　　　　until false；
　　　　　　　end 
		writer: begin
　　　　　　　　　repeat
　　　　　　　　　　Swait(mx,1,1；L,RN,0)；
　　　　　　　　　　perform write operation；
　　　　　　　　　　Ssignal(mx,1)；
　　　　　　　　until false；
　　　　　　　end
　　　　parend
　　end 
```

其中，Swait(mx，1，0)语句起着开关的作用。只要无writer进程进入写，mx=1，reader进程就都可以进入读。但只要一旦有writer进程进入写时，其mx=0，则任何reader进程就都无法进入读。Swait(mx，1，1；L，RN，0)语句表示仅当既无writer进程在写(mx=1)，又无reader进程在读(L=RN)时，writer进程才能进入临界区写。

## 2.5   进程通信

### 2.5.1　进程通信的类型

#### 1．共享存储器系统

 　(1) 基于共享数据结构的通信方式。在这种通信方式中，要求诸进程公用某些数据结构，借以实现诸进程间的信息交换。如在生产者—消费者问题中，就是用有界缓冲区这种数据结构来实现通信的。这里，公用数据结构的设置及对进程间同步的处理，都是程序员的职责。这无疑增加了程序员的负担，而操作系统却只须提供共享存储器。因此，这种通信方式是低效的，只适于传递相对少量的数据。

　(2) 基于共享存储区的通信方式。**为了传输大量数据，在存储器中划出了一块共享存储区，诸进程可通过对共享存储区中数据的读或写来实现通信。**这种通信方式属于高级通信。进程在通信前，先向系统申请获得共享存储区中的一个分区，并指定该分区的关键字；若系统已经给其他进程分配了这样的分区，则将该分区的描述符返回给申请者，继之，由申请者把获得的共享存储分区连接到本进程上；此后，便可像读、写普通存储器一样地读、写该公用存储分区。

#### 2．消息传递系统
　　消息传递系统(Message passing system)是当前应用最为广泛的一种进程间的通信机制。在该机制中，进程间的数据交换是以格式化的消息(message)为单位的；在计算机网络中，又把message称为报文。**程序员直接利用操作系统提供的一组通信命令(原语)，不仅能实现大量数据的传递，而且还隐藏了通信的实现细节，使通信过程对用户是透明的**，从而大大减化了通信程序编制的复杂性，因而获得了广泛的应用。 

　　特别值得一提的是，在当今最为流行的微内核操作系统中，微内核与服务器之间的通信，无一例外地都采用了消息传递机制。又由于它能很好地支持多处理机系统、分布式系统和计算机网络，因此它也成为这些领域最主要的通信工具。消息传递系统的通信方式属于高级通信方式。又因其实现方式的不同而进一步分成直接通信方式和间接通信方式两种。

#### 3．管道通信
　　所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。向管道(共享文件)提供输入的发送进程(即写进程)，以字符流形式将大量的数据送入管道；而接受管道输出的接收进程(即读进程)，则从管道中接收(读)数据。由于发送进程和接收进程是利用管道进行通信的，故又称为管道通信。这种方式首创于UNIX系统，由于它能有效地传送大量数据，因而又被引入到许多其它的操作系统中。 

　　为了协调双方的通信，管道机制必须提供以**下三方面的协调能力**：

　　(1) 互斥，即当一个进程正在对pipe执行读/写操作时，其它(另一)进程必须等待。

　　(2) 同步，指当写(输入)进程把一定数量(如4 KB)的数据写入pipe，便去睡眠等待，直到读(输出)进程取走数据后，再把它唤醒。当读进程读一空pipe时，也应睡眠等待，直至写进程将数据写入管道后，才将之唤醒。

　　(3) 确定对方是否存在，只有确定了对方已存在时，才能进行通信。

### 2.5.2　消息传递通信的实现方法
#### 1．直接通信方式
　　这是指发送进程利用 OS 所提供的发送命令，直接把消息发送给目标进程。此时，要求发送进程和接收进程都以显式方式提供对方的标识符。通常，系统提供下述两条通信命令
(原语)：

```
Send(Receiver，message)； 发送一个消息给接收进程;
Receive(Sender，message)； 接收Sender发来的消息;
```
　　例如，原语 Send(P2，m1) 表示将消息 m1 发送给接收进程 P2;而原语Receive(P1，m1)则表示接收由P1发来的消息m1。 

　　在某些情况下，接收进程可与多个发送进程通信，因此，它不可能事先指定发送进程。例如，用于提供打印服务的进程，它可以接收来自任何一个进程的“打印请求”消息。对于这样的应用，在接收进程接收消息的原语中，表示源进程的参数，也是完成通信后的返回值，接收原语可表示为：

```
Receive (id，message)； 
```

　　我们还可以利用直接通信原语来解决生产者—消费者问题。当生产者生产出一个产品(消息)后，便用Send原语将消息发送给消费者进程；而消费者进程则利用Receive原语来得到一个消息。如果消息尚未生产出来，消费者必须等待，直至生产者进程将消息发送过来。生产者—消费者的通信过程可分别描述如下：

```
repeat
　　　　　　...
　　　　produce an item in nextp；
　　　　　　...
　　　　send(consumer，nextp)；
　　　until false；
　　　repeat
　　　　receive(producer，nextc)；
　　　　　　...
　　　　consume the item in nextc；
　　until false； 

```
#### 2．间接通信方式
　　**间接通信方式指进程之间的通信需要通过作为共享数据结构的实体**。该实体用来暂存发送进程发送给目标进程的消息；接收进程则从该实体中取出对方发送给自己的消息。**通常把这种中间实体称为信箱**。消息在信箱中可以安全地保存，只允许核准的目标用户随时读取。因此，利用信箱通信方式，既可实现实时通信，又可实现非实时通信。
　　系统为信箱通信提供了若干条原语，分别用于信箱的创建、撤消和消息的发送、接收等。

　　(1) 信箱的创建和撤消。进程可利用信箱创建原语来建立一个新信箱。创建者进程应给出信箱名字、信箱属性(公用、私用或共享)；对于共享信箱，还应给出共享者的名字。当进程不再需要读信箱时，可用信箱撤消原语将之撤消。

　　(2) 消息的发送和接收。当进程之间要利用信箱进行通信时，必须使用共享信箱，并利用系统提供的下述通信原语进行通信：

```
　　Send(mailbox，message)；  将一个消息发送到指定信箱；

　　Receive(mailbox，message)； 从指定信箱中接收一个消息；
```

　　信箱可由操作系统创建，也可由用户进程创建，创建者是信箱的拥有者。据此，可把信箱分为以下三类。

　　1)私用信箱

　　用户进程可为自己建立一个新信箱，并作为该进程的一部分。信箱的拥有者有权从信箱中读取消息，其他用户则只能将自己构成的消息发送到该信箱中。这种私用信箱可采用单向通信链路的信箱来实现。当拥有该信箱的进程结束时，信箱也随之消失。

　　2)公用信箱

　　它由操作系统创建，并提供给系统中的所有核准进程使用。核准进程既可把消息发送到该信箱中，也可从信箱中读取发送给自己的消息。显然，公用信箱应采用双向通信链路的信箱来实现。通常，公用信箱在系统运行期间始终存在。

　　(3) 一对多关系。允许一个发送进程与多个接收进程进行交互，使发送进程可用广播方式向接收者(多个)发送消息。

　　(4) 多对多关系。允许建立一个公用信箱，让多个进程都能向信箱中投递消息；也可从信箱中取走属于自己的消息。

### 2.5.3　消息传递系统实现中的若干问题
#### 1．通信链路
　　**为使在发送进程和接收进程之间能进行通信，必须在两者之间建立一条通信链路**(communication link)。有两种方式建立通信链路。第一种方式是由发送进程在通信之前用显式的“建立连接”命令(原语)请求系统为之建立一条通信链路；在链路使用完后，也用显式方式拆除链路。这种方式主要用于计算机网络中。第二种方式是发送进程无须明确提出建立链路的请求，只须利用系统提供的发送命令(原语)，系统会自动地为之建立一条链路。这种方式主要用于单机系统中。

　　根据通信链路的连接方法，又可把通信链路分为两类：

　　(1) 点—点连接通信链路，这时的一条链路只连接两个结点(进程)；

　　(2) 多点连接链路，指用一条链路连接多个(n>2)结点(进程)。 

　　而根据通信方式的不同，则又可把链路分成两种：

　　(1) 单向通信链路，只允许发送进程向接收进程发送消息，或者相反； 

　　还可根据通信链路容量的不同而把链路分成两类：

- 一是无容量通信链路，在这种通信链路上没有缓冲区，因而不能暂存任何消息；
- 再者就是有容量通信链路，指在通信链路中设置了缓冲区，因而能暂存消息。缓冲区数目愈多，通信链路的容量愈大。

#### 2．消息的格式

　　在消息传递系统中所传递的消息，必须具有一定的消息格式。在单机系统环境中，由于发送进程和接收进程处于同一台机器中，有着相同的环境，故其消息格式比较简单；但在计算机网络环境下，不仅源和目标进程所处的环境不同，而且信息的传输距离很远，可能要跨越若干个完全不同的网络，致使所用的消息格式比较复杂。通常，可把一个消息分成消息头和消息正文两部分。消息头包括消息在传输时所需的控制信息，如源进程名、目标进程名、消息长度、消息类型、消息编号及发送的日期和时间；而消息正文则是发送进程实际上所发送的数据。

　　在某些OS中，消息采用比较短的定长消息格式，这便减少了对消息的处理和存储开销。这种方式可用于办公自动化系统中，为用户提供快速的便笺式通信；但这对要发送较长消息的用户是不方便的。在有的OS中，采用变长的消息格式，即进程所发送消息的长度是可变的。系统无论在处理还是在存储变长消息时，都可能会付出更多的开销，但这方便了用户。这两种消息格式各有其优缺点，故在很多系统(包括计算机网络)中，是同时都用的。

#### 3．进程同步方式

　　在进程之间进行通信时，**同样需要有进程同步机制，以使诸进程间能协调通信**。不论是发送进程，还是接收进程，在完成消息的发送或接收后，都存在两种可能性，即进程或者继续发送(接收)，或者阻塞。由此，我们可得到以下三种情况：

　　(1) 发送进程阻塞，接收进程阻塞。这种情况主要用于进程之间紧密同步(tight synchronization)，发送进程和接收进程之间无缓冲时。这两个进程平时都处于阻塞状态，直到有消息传递时。这种同步方式称为汇合(rendezrous)。 

　　(2) 发送进程不阻塞，接收进程阻塞。这是一种应用最广的进程同步方式。平时，发送进程不阻塞，因而它可以尽快地把一个或多个消息发送给多个目标； 而接收进程平时则处于阻塞状态，直到发送进程发来消息时才被唤醒。例如，在服务器上通常都设置了多个服务进程，它们分别用于提供不同的服务，如打印服务。平时，这些服务进程都处于阻塞状态，一旦有请求服务的消息到达时，系统便唤醒相应的服务进程，去完成用户所要求的服务。处理完后，若无新的服务请求，服务进程又阻塞。

　　(3) 发送进程和接收进程均不阻塞。这也是一种较常见的进程同步形式。平时，发送进程和接收进程都在忙于自己的事情，仅当发生某事件使它无法继续运行时，才把自己阻塞起来等待。例如，在发送进程和接收进程之间联系着一个消息队列时，该消息队列最多能接纳n个消息，这样，发送进程便可以连续地向消息队列中发送消息而不必等待；接收进程也可以连续地从消息队列中取得消息，也不必等待。只有当消息队列中的消息数已达到n个时，即消息队列已满，发送进程无法向消息队列中发送消息时才会阻塞；类似地，只有当消息队列中的消息数为0，接收进程已无法从消息队列中取得消息时才会阻塞。

### 2.5.4　消息缓冲队列通信机制
　　1) #### 消息缓冲区

　　**在消息缓冲队列通信方式中，主要利用的数据结构是消息缓冲区**。它可描述如下：

```
　　type message buffer=record
　　　　　　　　     sender	; 发送者进程标识符
　　　　　　　　     size	; 消息长度
　　　　　　　　     text	; 消息正文
　　　　　　　　     next	; 指向下一个消息缓冲区的指针
　　　　　　      end 
```

　　2) PCB中有关通信的数据项

　　在操作系统中采用了消息缓冲队列通信机制时，除了需要为进程设置消息缓冲队列外，还应在进程的PCB中增加消息队列队首指针，用于对消息队列进行操作，以及用于实现同步的互斥信号量mutex和资源信号量sm。在PCB中应增加的数据项可描述如下：

```
type processcontrol block=record
　　　　　　　　　　　　　...
　　　　　　　　     mq　　	    ； 消息队列队首指针
　　　　　　　　     mutex		  ； 消息队列互斥信号量
　　　　　　　　　   sm		    ； 消息队列资源信号量
　　　　　　　　　　　　　...
end 

```

#### 2．发送原语
  　发送进程在利用发送原语发送消息之前，应先在自己的内存空间设置一发送区a，见图2-14 所示。把待发送的消息正文、发送进程标识符、消息长度等信息填入其中，然后调用发送原语，把消息发送给目标(接收)进程。发送原语首先根据发送区a中所设置的消息长度a.size来申请一缓冲区i，接着把发送区a中的信息复制到缓冲区i中。为了能将i挂在接收进程的消息队列mq上，应先获得接收进程的内部标识符j，然后将i挂在j.mq上。由于该队列属于临界资源，故在执行insert操作的前后，都要执行wait和signal操作。  

```
发送原语可描述如下：
　　procedure send(receiver，a)
　　　begin
　　　　getbuf(a.size,i)；　　根据a.size申请缓冲区；
　　　　i.sender:= a.sender； 将发送区a中的信息复制到消息缓冲区i中；
　　　　i.size:=a.size；
　　　　i.text:=a.text；
　　　　i.next:=0；
　　　　getid(PCB set，receiver.j)；获得接收进程内部标识符；
　　　　wait(j.mutex)；
　　　　insert(j.mq，i)；　　	将消息缓冲区插入消息队列；
　　　　signal(j.mutex)；
　　　　signal(j.sm)；
　　end 
```

![2-14](https://images-1302683597.cos.ap-nanjing.myqcloud.com/images/StudyNotes/OperatringSystem/2/images_20220330002055.svg)

#### 3．接收原语
　　接收进程调用接收原语receive(b)，从自己的消息缓冲队列 mq 中摘下第一个消息缓冲区 i，并将其中的数据复制到以b为首址的指定消息接收区内。接收原语描述如下: 

```
procedure receive(b)
　　begin
　　　　j:= internal name；　 j为接收进程内部的标识符；
　　　　wait(j.sm)；
　　　　wait(j.mutex)；
　　　　remove(j.mq，i)；　 将消息队列中第一个消息移出；
　　　　signal(j.mutex)；
　　　　b.sender:=i.sender；　将消息缓冲区i中的信息复制到接收区b；
　　　　b.size:=i.size；
　　　　b.text:=i.text；
　　end 
```

## 2.6 线程
### 2.6.1　线程的基本概念
#### 1．线程的引入
　　如果说，在操作系统中引入进程的目的，是为了使多个程序能并发执行，以提高资源利用率和系统吞吐量，那么，在操作系统中再引入线程，则是为了**减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性**。为了说明这一点，我们首先来回顾进程的两个基本属性:

① 进程是一个可拥有资源的独立单位；

② 进程同时又是一个可独立调度和分派的基本单位。正是由于进程有这两个基本属性，才使之成为一个能独立运行的基本单位，从而也就构成了进程并发执行的基础。然而，为使程序能并发执行，系统还必须进行以下的一系列操作。 

　　1)创建进程

　　系统在创建一个进程时，必须为它分配其所必需的、除处理机以外的所有资源，如内存空间、I/O设备，以及建立相应的PCB。

　　2)撤消进程

　　系统在撤消进程时，又必须先对其所占有的资源执行回收操作，然后再撤消PCB。 

　　3)进程切换

　　对进程进行切换时，由于要保留当前进程的CPU环境和设置新选中进程的CPU环境，因而须花费不少的处理机时间。

　　换言之，由于进程是一个资源的拥有者，因而在创建、撤消和切换中，系统必须为之付出较大的时空开销。正因如此，在系统中所设置的进程，其数目不宜过多，进程切换的频率也不宜过高，这也就限制了并发程度的进一步提高。

　　如何能使多个程序更好地并发执行同时又尽量减少系统的开销，已成为近年来设计操作系统时所追求的重要目标。有不少研究操作系统的学者们想到，若能将进程的上述两个属性分开，由操作系统分开处理，亦即对于作为调度和分派的基本单位，不同时作为拥有资源的单位，以做到“轻装上阵”；而对于拥有资源的基本单位，又不对之进行频繁的切换。正是在这种思想的指导下，形成了线程的概念。

#### 2．线程与进程的比较
　　1)调度
　　在传统的操作系统中，作为拥有资源的基本单位和独立调度、分派的基本单位都是进程。而在引入线程的操作系统中，则把线程作为调度和分派的基本单位，而进程作为资源拥有的基本单位，把传统进程的两个属性分开，使线程基本上不拥有资源，这样线程便能轻装前进，从而可显著地提高系统的并发程度。在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一个进程中的线程时，将会引起进程的切换。 

　　2)并发性

　　在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，使得操作系统具有更好的并发性，从而能更加有效地提高系统资源的利用率和系统的吞吐量。例如，在一个未引入线程的单CPU操作系统中，若仅设置一个文件服务进程，当该进程由于某种原因而被阻塞时，便没有其它的文件服务进程来提供服务。在引入线程的操作系统中，则可以在一个文件服务进程中设置多个服务线程。当第一个线程等待时，文件服务进程中的第二个线程可以继续运行，以提供文件服务；当第二个线程阻塞时，则可由第三个继续执行，提供服务。显然，这样的方法可以显著地提高文件服务的质量和系统的吞吐量。　

　　3)拥有资源

　　不论是传统的操作系统，还是引入了线程的操作系统，进程都可以拥有资源，是系统中拥有资源的一个基本单位。一般而言，线程自己不拥有系统资源(也有一点必不可少的资源)，但它可以访问其隶属进程的资源，即一个进程的代码段、数据段及所拥有的系统资源，如已打开的文件、I/O设备等，可以供该进程中的所有线程所共享。

　　4)系统开销

　　在创建或撤消进程时，系统都要为之创建和回收进程控制块，分配或回收资源，如内存空间和I/O设备等，操作系统所付出的开销明显大于线程创建或撤消时的开销。类似地，在进程切换时，涉及到当前进程CPU环境的保存及新被调度运行进程的CPU环境的设置，而线程的切换则仅需保存和设置少量寄存器内容，不涉及存储器管理方面的操作，所以就切换代价而言，进程也是远高于线程的。此外，由于一个进程中的多个线程具有相同的地址空间，在同步和通信的实现方面线程也比进程容易。在一些操作系统中，线程的切换、同步和通信都无须操作系统内核的干预。

#### 3．线程的属性

　　在多线程OS中，通常是在一个进程中包括多个线程，每个线程都是作为利用CPU的基本单位，是花费最小开销的实体。线程具有下述属性。

　　(1) 轻型实体。线程中的实体基本上不拥有系统资源，只是有一点必不可少的、 能保证其独立运行的资源，比如，**在每个线程中都应具有一个用于控制线程运行的线程控制块TCB，用于指示被执行指令序列的程序计数器，保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。**

　　(2) 独立调度和分派的基本单位。在多线程 OS 中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小。

　　(3) 可并发执行。在一个进程中的多个线程之间可以并发执行，甚至允许在一个进程中的所有线程都能并发执行；同样，不同进程中的线程也能并发执行。

　　(4) 共享进程资源。在同一进程中的各个线程都可以共享该进程所拥有的资源，这首先表现在所有线程都具有相同的地址空间(进程的地址空间)。这意味着线程可以访问该地址空间中的每一个虚地址；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。

#### 4．线程的状态

　　(1) 状态参数。在OS中的每一个线程都可以利用线程标识符和一组状态参数进行描述。状态参数通常有这样几项：

① 寄存器状态，它包括程序计数器PC和堆栈指针中的内容；

② 堆栈，在堆栈中通常保存有局部变量和返回地址；

③ 线程运行状态，用于描述线程正处于何种运行状态；

④ 优先级，描述线程执行的优先程度；

⑤ 线程专有存储器，用于保存线程自己的局部变量拷贝；

⑥ 信号屏蔽，即对某些信号加以屏蔽。 

　　(2) 线程运行状态。如同传统的进程一样，在各线程之间也存在着共享资源和相互合作的制约关系，致使线程在运行时也具有间断性。相应地，线程在运行时也具有下述三种基本状态: 

① 执行状态，表示线程正获得处理机而运行；

② 就绪状态，指线程已具备了各种执行条件，一旦获得CPU便可执行的状态；

③ 阻塞状态，指线程在执行中因某事件而受阻，处于暂停执行时的状态。 　　

#### 5．线程的创建和终止
　　在多线程OS环境下，应用程序在启动时，通常仅有一个线程在执行，该线程被人们称为“初始化线程”。它可根据需要再去创建若干个线程。在创建新线程时，需要利用一个线程创建函数(或系统调用)，并提供相应的参数，如指向线程主程序的入口指针、堆栈的大小，以及用于调度的优先级等。在线程创建函数执行完后，将返回一个线程标识符供以后使用。 

　　如同进程一样，线程也是具有生命期的。终止线程的方式有两种：一种是在线程完成了自己的工作后自愿退出；另一种是线程在运行中出现错误或由于某种原因而被其它线程强行终止。但有些线程(主要是系统线程)，在它们一旦被建立起来之后，便一直运行下去而不再被终止。在大多数的OS中，线程被中止后并不立即释放它所占有的资源，只有当进程中的其它线程执行了分离函数后，被终止的线程才与资源分离，此时的资源才能被其它线程利用。

　　虽已被终止但尚未释放资源的线程，仍可以被需要它的线程所调用，以使被终止线程重新恢复运行。为此，调用者线程须调用一条被称为“等待线程终止”的连接命令，来与该线程进行连接。如果在一个调用者线程调用“等待线程终止”的连接命令试图与指定线程相连接时，若指定线程尚未被终止，则调用连接命令的线程将会阻塞，直至指定线程被终止后才能实现它与调用者线程的连接并继续执行；若指定线程已被终止，则调用者线程不会被阻塞而是继续执行。

#### 6．多线程OS中的进程

　　在多线程OS中，**进程是作为拥有系统资源的基本单位，通常的进程都包含多个线程并为它们提供资源**，但此时的进程就不再作为一个执行的实体。多线程OS中的进程有以下属性：

　　(1) 作为系统资源分配的单位。在多线程OS中，仍是将进程作为系统资源分配的基本单位，在任一进程中所拥有的资源包括受到分别保护的用户地址空间、用于实现进程间和线程间同步和通信的机制、已打开的文件和已申请到的I/O设备，以及一张由核心进程维护的地址映射表，该表用于实现用户程序的逻辑地址到其内存物理地址的映射。

　　(2) 可包括多个线程。通常，一个进程都含有多个相对独立的线程，其数目可多可少，但至少也要有一个线程，由进程为这些(个)线程提供资源及运行环境，使这些线程可并发执行。在OS中的所有线程都只能属于某一个特定进程。

　　(3) 进程不是一个可执行的实体。在多线程OS中，是把线程作为独立运行的基本单位，所以此时的进程已不再是一个可执行的实体。虽然如此，进程仍具有与执行相关的状态。例如，所谓进程处于“执行”状态，实际上是指该进程中的某线程正在执行。此外，对进程所施加的与进程状态有关的操作，也对其线程起作用。例如，在把某个进程挂起时，该进程中的所有线程也都将被挂起；又如，在把某进程激活时，属于该进程的所有线程也都将被激活。

### 2.6.2　线程间的同步和通信
#### 1．互斥锁(mutex)
　　**互斥锁是一种比较简单的、用于实现线程间对资源互斥访问的机制。**由于操作互斥锁的时间和空间开销都较低，因而较适合于高频度使用的关键共享数据和程序段。互斥锁可以有两种状态，即开锁(unlock)和关锁(lock)状态。相应地，可用两条命令(函数)对互斥锁进行操作。其中的关锁lock操作用于将mutex关上，开锁操作unlock则用于打开mutex。 

　　当一个线程需要读/写一个共享数据段时，线程首先应为该数据段所设置的mutex执行关锁命令。命令首先判别mutex的状态，如果它已处于关锁状态，则试图访问该数据段的线程将被阻塞；而如果mutex是处于开锁状态，则将mutex关上后便去读/写该数据段。在线程完成对数据的读/写后，必须再发出开锁命令将mutex打开，同时还须将阻塞在该互斥锁上的一个线程唤醒，其它的线程仍被阻塞在等待mutex打开的队列上。

　　另外，为了减少线程被阻塞的机会，在有的系统中还提供了一种用于mutex上的操作命令Trylock。当一个线程在利用Trylock命令去访问mutex时，若mutex处于开锁状态，Trylock将返回一个指示成功的状态码；反之，若mutex处于关锁状态，则Trylock并不会阻塞该线程，而只是返回一个指示操作失败的状态码。 

#### 2．条件变量
　　**在许多情况下，只利用mutex来实现互斥访问可能会引起死锁**，我们通过一个例子来说明这一点。有一个线程在对mutex 1执行关锁操作成功后，便进入一临界区C，若在临界区内该线程又须访问某个临界资源R，同样也为R设置另一互斥锁mutex 2。假如资源R此时正处于忙碌状态，线程在对mutex 2执行关锁操作后必将被阻塞，这样将使mutex 1一直保持关锁状态；如果保持了资源R的线程也要求进入临界区C，但由于mutex 1一直保持关锁状态而无法进入临界区，这样便形成了死锁。为了解决这个问题便引入了条件变量。 

　　每一个条件变量通常都与一个互斥锁一起使用，亦即，在创建一个互斥锁时便联系着一个条件变量。单纯的互斥锁用于短期锁定，主要是用来保证对临界区的互斥进入。而条件变量则用于线程的长期等待，直至所等待的资源成为可用的资源。

　　现在，我们看看如何利用互斥锁和条件变量来实现对资源R的访问。线程首先对 mutex 执行关锁操作，若成功便进入临界区，然后查找用于描述该资源状态的数据结构，以了解资源的情况。只要发现所需资源R正处于忙碌状态，线程便转为等待状态，并对 mutex 执行开锁操作后，等待该资源被释放；若资源处于空闲状态，表明线程可以使用该资源，于是将该资源设置为忙碌状态，再对mutex执行开锁操作。下面给出了对上述资源的申请(左半部分)和释放(右半部分)操作的描述。

```
Lock mutex　　　　　　　　　　	Lock mutex
　　check data structures；         	mark resource as free；
　　while(resource busy)；　       	unlock mutex；
　　　wait(condition variable)；　  wakeup(condition variable)；
　　mark resource as busy；
　unlock mutex； 

```

　　原来占有资源R的线程在使用完该资源后，便按照右半部分的描述释放该资源，其中的wakeup(condition variable)表示去唤醒在指定条件变量上等待的一个或多个线程。在大多数情况下，由于所释放的是临界资源，此时所唤醒的只能是在条件变量上等待的某一个线程，其它线程仍继续在该队列上等待。但如果线程所释放的是一个数据文件，该文件允许多个线程同时对它执行读操作。在这种情况下，当一个写线程完成写操作并释放该文件后，如果此时在该条件变量上还有多个读线程在等待，则该线程可以唤醒所有的等待线程。

#### 3．信号量机制

1)私用信号量(private samephore)

　　当某线程需利用信号量来实现同一进程中各线程之间的同步时，可调用创建信号量的命令来创建一私用信号量，其数据结构存放在应用程序的地址空间中。私用信号量属于特定的进程所有，OS并不知道私用信号量的存在，因此，一旦发生私用信号量的占用者异常结束或正常结束，但并未释放该信号量所占有空间的情况时，系统将无法使它恢复为0(空)，也不能将它传送给下一个请求它的线程。 

2)公用信号量 (public semaphort)

   　　公用信号量是为实现不同进程间或不同进程中各线程之间的同步而设置的。由于它有着一个公开的名字供所有的进程使用，故而把它称为公用信号量。其数据结构是存放在受保护的系统存储区中，由OS为它分配空间并进行管理，故也称为系统信号量。如果信号量的占有者在结束时未释放该公用信号量，则OS会自动将该信号量空间回收，并通知下一进程。可见，公用信号量是一种比较安全的同步机制。 

### 2.6.3　线程的实现方式
#### 1．内核支持线程
　　对于通常的进程，无论是系统进程还是用户进程，进程的创建、 撤消，以及要求由系统设备完成的I/O操作，都是利用系统调用而进入内核，再由内核中的相应处理程序予以完成的。进程的切换同样是在内核的支持下实现的。因此我们说，不论什么进程，它们都是在操作系统内核的支持下运行的，是与内核紧密相关的。 

　　这里所谓的内核支持线程 KST(Kernel Supported Threads)，**也都同样是在内核的支持下运行的，即无论是用户进程中的线程，还是系统进程中的线程，他们的创建、撤消和切换等也是依靠内核，在内核空间实现的**。此外，在内核空间还为每一个内核支持线程设置了一个线程控制块，内核是根据该控制块而感知某线程的存在，并对其加以控制。

　　这种线程实现方式主要有如下四个优点：

　　(1) 在多处理器系统中，内核能够同时调度同一进程中多个线程并行执行； 
　　(2) 如果进程中的一个线程被阻塞了，内核可以调度该进程中的其它线程占有处理器运行，也可以运行其它进程中的线程；
　　(3) 内核支持线程具有很小的数据结构和堆栈，线程的切换比较快，切换开销小；
　　(4) 内核本身也可以采用多线程技术，可以提高系统的执行速度和效率。

　　内核支持线程的主要缺点是：对于用户的线程切换而言，其模式切换的开销较大，在同一个进程中，从一个线程切换到另一个线程时，需要从用户态转到内核态进行，这是因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的，系统开销较大。 

#### 2．用户级线程
　　用户级线程 ULT(User Level Threads) 仅存在于用户空间中。对于这种线程的创建、撤消、线程之间的同步与通信等功能，都无须利用系统调用来实现。对于用户级线程的切换，通常发生在一个应用进程的诸多线程之间，这时，也同样无须内核的支持。由于切换的规则远比进程调度和切换的规则简单，因而使线程的切换速度特别快。可见，这种线程是与内核无关的。我们可以为一个应用程序建立多个用户级线程。在一个系统中的用户级线程的数目可以达到数百个至数千个。由于这些线程的任务控制块都是设置在用户空间，而线程所执行的操作也无须内核的帮助，因而内核完全不知道用户级线程的存在。 

　　值得说明的是，对于设置了用户级线程的系统，其调度仍是以进程为单位进行的。在采用轮转调度算法时，各个进程轮流执行一个时间片，这对诸进程而言似乎是公平的。但假如在进程A中包含了一个用户级线程，而在另一个进程B中含有100个用户级线程，这样，进程A中线程的运行时间将是进程B中各线程运行时间的100倍；相应地，其速度要快上100倍。

　　假如系统中设置的是内核支持线程，则调度便是以线程为单位进行的。在采用轮转法调度时，是各个线程轮流执行一个时间片。同样假定进程A中只有一个内核支持线程，而在进程B中有100个内核支持线程。此时进程B可以获得的CPU时间是进程A的100倍，且进程B可使100个系统调用并发工作。 

　　使用用户级线程方式有许多优点，主要表现在如下三个方面：

　　(1) 线程切换不需要转换到内核空间，对一个进程而言，其所有线程的管理数据结构均在该进程的用户空间中，管理线程切换的线程库也在用户地址空间运行。因此，进程不必切换到内核方式来做线程管理，从而节省了模式切换的开销，也节省了内核的宝贵资源。

　　(2) 调度算法可以是进程专用的。在不干扰操作系统调度的情况下，不同的进程可以根据自身需要，选择不同的调度算法对自己的线程进行管理和调度，而与操作系统的低级调度算法是无关的。 

　　(3) 用户级线程的实现与操作系统平台无关，因为对于线程管理的代码是在用户程序内的，属于用户程序的一部分，所有的应用程序都可以对之进行共享。因此，用户级线程甚至可以在不支持线程机制的操作系统平台上实现。

　　用户级线程实现方式的主要缺点在于如下两个方面：

　　(1) 系统调用的阻塞问题。在基于进程机制的操作系统中，大多数系统调用将阻塞进程，因此，当线程执行一个系统调用时，不仅该线程被阻塞，而且进程内的所有线程都会被阻塞。而在内核支持线程方式中，则进程中的其它线程仍然可以运行。

　　(2) 在单纯的用户级线程实现方式中，多线程应用不能利用多处理机进行多重处理的优点。内核每次分配给一个进程的仅有一个CPU，因此进程中仅有一个线程能执行，在该线程放弃CPU之前，其它线程只能等待。 

#### 3．组合方式

　　有些操作系统把用户级线程和内核支持线程两种方式进行组合，提供了组合方式 ULT/KST 线程。在组合方式线程系统中，内核支持多 KST 线程的建立、调度和管理，同时，也允许用户应用程序建立、调度和管理用户级线程。一些内核支持线程对应多个用户级线程，程序员可按应用需要和机器配置对内核支持线程数目进行调整，以达到较好的效果。组合方式线程中，同一个进程内的多个线程可以同时在多处理器上并行执行，而且在阻塞一个线程时，并不需要将整个进程阻塞。所以，组合方式多线程机制能够结合KST和ULT两者的优点，并克服了其各自的不足。  

### 2.6.4　线程的实现
#### 1．内核支持线程的实现
　　在仅设置了内核支持线程的 OS 中，一种可能的线程控制方法是，系统在创建一个新进程时，便为它分配一个任务数据区PTDA(Per Task Data Area)，其中包括若干个线程控制块 TCB 空间，如图2-15所示。在每一个 TCB 中可保存线程标识符、优先级、线程运行的 CPU 状态等信息。虽然这些信息与用户级线程TCB中的信息相同，但现在却是被保存在内核空间中。 

![2-15](https://images-1302683597.cos.ap-nanjing.myqcloud.com/images/StudyNotes/OperatringSystem/2/images_20220330002105.svg)

　　每当进程要创建一个线程时，便为新线程分配一个TCB，将有关信息填入该TCB中，并为之分配必要的资源，如为线程分配数百至数千个字节的栈空间和局部存储区，于是新创建的线程便有条件立即执行。当PTDA中的所有TCB空间已用完，而进程又要创建新的线程时，只要其所创建的线程数目未超过系统的允许值(通常为数十至数百个)，系统可再为之分配新的TCB空间；在撤消一个线程时，也应回收该线程的所有资源和TCB。可见，内核支持线程的创建、 撤消均与进程的相类似。在有的系统中为了减少创建和撤消一个线程时的开销，在撤消一个线程时，并不立即回收该线程的资源和TCB，当以后再要创建一个新线程时，便可直接利用已被撤消但仍保持有资源和TCB的线程作为新线程。 

　　内核支持线程的调度和切换与进程的调度和切换十分相似，也分抢占式方式和非抢占方式两种。在线程的调度算法上，同样可采用时间片轮转法、优先权算法等。当线程调度选中一个线程后，便将处理机分配给它。当然，线程在调度和切换上所花费的开销，要比进程的小得多。 

#### 2．用户级线程的实现
　　用户级线程是在用户空间实现的。所有的用户级线程都具有相同的结构，它们都运行在一个中间系统的上面。当前有两种方式实现的中间系统，即运行时系统和内核控制线程。
　　1)运行时系统(Runtime System)
　　所谓“运行时系统”，实质上是**用于管理和控制线程的函数(过程)的集合**，其中包括用于创建和撤消线程的函数、 线程同步和通信的函数以及实现线程调度的函数等。正因为有这些函数，才能使用户级线程与内核无关。**运行时系统中的所有函数都驻留在用户空间，并作为用户级线程与内核之间的接口。** 

　　在传统的OS中，进程在切换时必须先由用户态转为核心态，再由核心来执行切换任务； 而用户级线程在切换时则不需转入核心态，而是由运行时系统中的线程切换过程来执行切换任务。该过程将线程的CPU状态保存在该线程的堆栈中，然后按照一定的算法选择一个处于就绪状态的新线程运行，将新线程堆栈中的CPU状态装入到CPU相应的寄存器中，一旦将栈指针和程序计数器切换后，便开始了新线程的运行。由于用户级线程的切换无需进入内核，且切换操作简单，因而使用户级线程的切换速度非常快。 

　　不论在传统的OS中，还是在多线程OS中，系统资源都是由内核管理的。在传统的OS中，进程是利用OS提供的系统调用来请求系统资源的，系统调用通过软中断(如trap)机制进入OS内核，由内核来完成相应资源的分配。用户级线程是不能利用系统调用的。当线程需要系统资源时，是将该要求传送给运行时系统，由后者通过相应的系统调用来获得系统资源的。 

　　2)内核控制线程
　　这种线程又称为轻型进程LWP(Light Weight Process)。每一个进程都可拥有多个LWP，同用户级线程一样，每个LWP都有自己的数据结构(如TCB)，其中包括线程标识符、优先级、状态，另外还有栈和局部存储区等。它们也可以共享进程所拥有的资源。LWP可通过系统调用来获得内核提供的服务，这样，当一个用户级线程运行时，只要将它连接到一个LWP上，此时它便具有了内核支持线程的所有属性。这种线程实现方式就是组合方式。 

　　在一个系统中的用户级线程数量可能很大，为了节省系统开销，不可能设置太多的 LWP，而把这些 LWP 做成一个缓冲池，称为“线程池”。用户进程中的任一用户线程都可以连接到 LWP 池中的任何一个 LWP 上。为使每一用户级线程都能利用 LWP 与内核通信，可以使多个用户级线程多路复用一个LWP，但只有当前连接到LWP上的线程才能与内核通信，其余进程或者阻塞，或者等待LWP。而每一个LWP都要连接到一个内核级线程上，这样，通过LWP可把用户级线程与内核线程连接起来，用户级线程可通过LWP来访问内核，但内核所看到的总是多个LWP而看不到用户级线程。亦即，由LWP实现了在内核与用户级线程之间的隔离，从而使用户级线程与内核无关。图2-16示出了利用轻型进程作为中间系统时用户级线程的实现方法。 

![2-16](https://images-1302683597.cos.ap-nanjing.myqcloud.com/images/StudyNotes/OperatringSystem/2/images_20220330002112.svg)

　　当用户级线程不需要与内核通信时，并不需要LWP；而当要通信时，便需借助于LWP，而且每个要通信的用户级线程都需要一个LWP。例如，在一个任务中，如果同时有5个用户级线程发出了对文件的读、写请求，这就需要有5个LWP来予以帮助，即由LWP将对文件的读、写请求发送给相应的内核级线程，再由后者执行具体的读、写操作。如果一个任务中只有4个LWP，则只能有4个用户级线程的读、写请求被传送给内核线程，余下的一个用户级线程必须等待。 

　　在内核级线程执行操作时，如果发生阻塞，则与之相连接的多个LWP也将随之阻塞，进而使连接到LWP上的用户级线程也被阻塞。如果进程中只包含了一个LWP，此时进程也应阻塞。这种情况与前述的传统OS一样，在进程执行系统调用时，该进程实际上是阻塞的。但如果在一个进程中含有多个LWP，则当一个LWP阻塞时，进程中的另一个LWP可继续执行；即使进程中的所有LWP全部阻塞，进程中的线程也仍然能继续执行，只是不能再去访问内核。 

#### 3．用户级线程与内核控制线程的连接
　　1) 一对一模型
该模型是为每一个用户线程都设置一个内核控制线程与之连接，当一个线程阻塞时，允许调度另一个线程运行。在多处理机系统中，则有多个线程并行执行。
该模型并行能力较强，但每创建一个用户线程相应地就需要创建一个内核线程，开销较大，因此需要限制整个系统的线程数。Windows 2000、Windows NT、OS/2等系统上都实现了该模型。 

　　2) 多对一模型
该模型是将多个用户线程映射到一个内核控制线程，为了管理方便，这些用户线程一般属于一个进程，运行在该进程的用户空间，对这些线程的调度和管理也是在该进程的用户空间中完成。当用户线程需要访问内核时，才将其映射到一个内核控制线程上，但每次只允许一个线程进行映射。该模型的主要优点是线程管理的开销小，效率高，但当一个线程在访问内核时发生阻塞，则整个进程都会被阻塞，而且在多处理机系统中，一个进程的多个线程无法实现并行。 

  3. 多对多模型

​         该模型结合上述两种模型的优点，将多个用户线程映射到多个内核控制线程，内核控制线程的数目可以根据应用进程和系统的不同而变化，可以比用户线程少，也可以与之相同。
