# 启动、中断和调用

## 1.启动

通电之后，如何启动。

- **DISK：** 存放 OS 和 Bootloader。 
- **BIOS：** 基本 I/O 处理系统。


开始加电时，BIOS 从 CS:IP 这个地址开始执行，之后完成一系列工作，包括：

- POST（加电自检），寻找显卡和执行 BIOS 等。

具体分为两步

### 1.1.BIOS 加载 Bootloader

Bootloader 放在硬盘的第一个主引导扇区（512字节）。BIOS 从硬盘的第一个扇区寻找，一下便找到Bootloader，Bootloader 再负责加载OS。

### 1.2.Bootloader 加载 OS

之后，由Bootloader将操作系统的代码和数据从硬盘加载到内存中。随后，控制权交给到OS。（跳转到OS的地址）

## 2.操作系统与设备和程序交互

- 操作系统面向外设，通过中断和 I/O 进行处理；
- 操作系统面向应用程序通过系统调用和异常提供支持。

### 2.1一些概念

- **系统调用（来源于应用程序）**：应用程序主动向操作系统发出服务请求；
- **异常（来源于不良的应用程序）**：非法指令或者其他坏的处理状态（如：内存出错）；
- **中断（来源于外设）**：来自不同的硬件设备的计时器和网络中断。

#### 2.1.1.从源头区分中断、异常和系统调用

- 中断： 外设（即非CPU产生）
- 异常： 应用程序意想不到的行为
- 系统调用： 应用程序请求操作提供服务

#### 2.1.2.从处理时间区分中断、异常和系统调用

- 中断： 异步（不知什么时候产生）
- 异常： 同步（由指令确定时间）
- 系统调用： 异步或同步（发出请求的点是同步的，但是获取返回的点可能是异步的）

#### 2.1.3.从响应区分中断、异常和系统调用

- 中断： 持续，对用户应用程序是透明的（感觉不到）
- 异常： 杀死或者重新执行意想不到的程序指令
- 系统调用： 等待和持续

| 类型     | 源头                     | 处理时间   | 响应                 |
| -------- | ------------------------ | ---------- | -------------------- |
| 中断     | 外设                     | 异步       | 持续，对应用程序透明 |
| 异常     | 应用程序意向不到的行为   | 同步       | 杀死或重新执行指令   |
| 系统调用 | 应用程序请求系统提供服务 | 同步或异步 | 等待和持续           |

#### 2.1.4.为什么应用程序不能直接访问外设呢？（必须要经过操作系统？）

- 在计算机运行中，内核是被信任的第三方；
- 只有内核可以执行特权指令安全；
- 为应用程序提供了统一的外设接口，方便应用程序开发。

### 2.2.中断、异常和系统调用的处理流程

中断、异常都有针对软硬件的处理过程。**对中断和异常进行编号（中断表），编号对应特定地址，跳到处理历程，解决问题。**

但是，中断打断了一个程序的正常执行，因此要设置**保护与恢复机制。**

**中断**

- 硬件设置中断标记（CPU初始化
   - 将内部、外部事件设置中断标记，产生中断号 （ID），来找到对应的处理历程。
- 软件
   - 保存当前处理状态（寄存器之类的数据便于程序从被打断的点继续执行）；
   - 根据中断事件的 ID 跳转到中断服务程序，由中断服务程序处理；
   - 清除中断标记；恢复之前保存的处理状态。

 因此，应用程序完全不用感知到中断的产生。

**异常**

得到异常编号：

- 保存现场；
- 异常处理（杀死了产生异常的程序or重新执行异常指令）；
- 恢复现场

**系统调用**

例：标准C库的例子。

- 应用程序调用 printf() 时，会触发系统调用 write()。

**程序访问主要是通过高层次 API 接口而不是直接进行系统调用。**例如：

- Win32 API 用于 Windows
- POSIX API 用于 POSIX-based systems (包括 UNIX，LINUX，Mac OS X 的所用版本)
- Java API用于JAVA虚拟机（JVM），JVM 再访问 Win32 API 等

## 3.补充

**程序的用户态**：是指级别比较低的状态；
**操作系统的内核态**：是等级最高的状态；
**系统调用**：应用程序发出系统调用之后，要切换堆栈（程序由自己的堆栈，操作系统的堆栈与其不同），同时实现由用户态到内核态的转换。

## 4.操作系统的边界开销

跨越操作系统边界更安全，但开销更大，在执行时间上的开销超过程序调用

开销有：

- 建立中断/异常/系统调用号与对应服务
- 建立内核堆栈
- 验证参数（操作系统并不信任程序，要花费时间检查参数）
- 内核态映射到用户态的地址空间，不能使用简单的改变指针的方法，要拷贝
- 内核态独立地址空间 TLB
