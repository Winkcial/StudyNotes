# channel 管道

现在要求计算 1-200 的各个数的阶乘，并把计算结果放到 map 中，最后显示出来。

要求使用 goroutine 来完成。

- 使用 goroutine 来完成，效率高，但是会出现并发、并行的问题。
- 不同的 goroutine 该如何进行通讯呢？

运行下面的代码，看看会出现什么样的错误？


```go
var (
	mymap = make(map[int]int64, 10)
)

func test(n int) {
	res := 1
	for i := 1; i <= n; i++ {
		res *= i
	}
	mymap[n] = int64(res)
}

func main() {
	// 开启多个协程
	for i := 1; i <= 200; i++ {
		go test(i)
	}
	for i,v:=range mymap{
		fmt.Printf("map[%d]=%d\n",i,v)
	}
}
```

并发错误：同时向一个 map 写数据。

## 不同 goroutine 之间通信

### 全局变量加锁



```go
var (
	mymap = make(map[int]int, 10)
	lock  sync.Mutex // 声明一个全局锁
)

func test(n int) {
	res := 1
	for i := 1; i <= n; i++ {
		res *= i
	}
	lock.Lock() //加锁
	mymap[n] = int(res)
	lock.Unlock() //解锁
}

func main() {
	fmt.Println(123)
	// 开启多个协程
	for i := 1; i <= 200; i++ {
		go test(i)
	}

	time.Sleep(time.Second * 10) //等待所有的 goroutine 运行结束

	lock.Lock()
	for i, v := range mymap {
		fmt.Printf("map[%d]=%d\n", i, v)
	}
	lock.Unlock()
}

```

使用全局变量加锁解决 goroutine 的通讯，只能算是勉强。

1）主线程等待所有 goroutine 运行结束的时间难以估算。

2）通过全局变量加锁实现通讯，也不利于多个协程对全局变量的读写操作。

​    

推荐使用 channel 来完成线程的通讯。

### 使用 channel 

1）channel 本质是一个队列；

2）线程安全，多 goroutine 访问时不需要加锁，channel 本身就是线程安全的；

3）channel 是有类型的，一个 string 类型的 channel 只能存放 string 类型数据。

## 声明管道、写入读取管道数据



```go
var 变量名 chan 数据类型
```

- 管道是引用类型；
- 管道必须初始化才能写入数据，即 make 后才能使用；
- 管道是有类型，同一个管道中的数据必须一样。

创建一个可以存放三个 int 数据的 channel 

```go
func main() {
	// 创建一个可以存放三个 int 类型数据的 channel
	var intChann chan int
	intChann = make(chan int, 3)

	// 输出

	fmt.Printf("intChann=%v\n", intChann)
}
```

运行结果：

```go
intChann=0xc000020100
```

修改一下代码向管道写入数据

```go
func main() {
	// 创建一个可以存放三个 int 类型数据的 channel
	var intChann chan int
	intChann = make(chan int, 3)

	// 输出

	fmt.Printf("intChann=%v\n", intChann)

	// 向管道写入数据

	intChann <- 10 //第一个数据 10
	num := 12
	intChann <- num //第二个数据 12
	fmt.Printf("channel len=%v cap=%v\n", len(intChann), cap(intChann))

}
```

运行结果：

```go
intChann=0xc000020100
channel len=2 cap=3
```

- 向管道写入的数据不能超过它的容量。

修改代码，读取管道中的数据

```go
func main() {
	// 创建一个可以存放三个 int 类型数据的 channel
	var intChann chan int
	intChann = make(chan int, 3)

	// 输出

	fmt.Printf("intChann=%v\n", intChann)

	// 向管道写入数据

	intChann <- 10 //第一个数据 10
	num := 12
	intChann <- num //第二个数据 12
	intChann <- 300
	fmt.Printf("channel len=%v cap=%v\n", len(intChann), cap(intChann))

	// 从管道中取数据
	var num2 int
	num2 = <-intChann
    <-inrChann // 取走数据但不用变量接收 
	fmt.Printf("num2=%v\n", num2)
	// 在没有使用协程的情况下，如果我们的管道数据已经取完，再取就会报错。

}
```

