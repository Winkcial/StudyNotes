# 哈希表

## uthash简介

由于C语言本身不存在哈希，但是当需要使用哈希表的时候自己构建哈希会异常复杂。

因此，我们可以调用开源的第三方头文件，这只是一个头文件：uthash.h。我们需要做的就是将头文件复制到您的项目中，然后：#include "uthash.h"。由于uthash仅是头文件，因此没有可链接的库代码。

使用 uthash 添加，查找和删除通常是常数时间的操作，此哈希的目标是简约高效。它大约有1000行C。它会自动内联，因为它是作为宏实现的。 

uthash还包括三个额外的头文件，主要提供链表，动态数组和字符串。utlist.h为C结构提供了链接列表宏。utarray.h使用宏实现动态数组。utstring.h实现基本的动态字符串。

## uthash的使用

### 定义结构体

这里我们将 id 作为一个索引值，也就是 key ，将 name 作为 value。

```c
#include "uthash.h"
struct my_struct {
    int id;                    /* key */
    char name[10];
    UT_hash_handle hh;         /* makes this structure hashable */
};
/*声明哈希为NULL指针*/
struct my_struct *users = NULL;    /* important! initialize to NULL */
```

> 注意：一定要包含UT_hash_handle hh;hh不需要初始化。它可以命名为任何名称，但是我们一般都命名为hh。

### 添加

- HASH_ADD_INT 表示添加的键值为int类型 ；

- HASH_ADD_STR 表示添加的键值为字符串类型； 

- HASH_ADD_PTR 表示添加的键值为指针类型 ；

- HASH_ADD 表示添加的键值可以是任意类型。



```c
void add_user(int user_id, char *name) {
    struct my_struct *s;
    /*重复性检查，当把两个相同key值的结构体添加到哈希表中时会报错*/
    HASH_FIND_INT(users, &user_id, s);  /* id already in the hash? */
    /*只有在哈希中不存在ID的情况下，我们才创建该项目并将其添加。否则，我们只修改已经存在的结构。*/
    if (s==NULL) {
      s = (struct my_struct *)malloc(sizeof *s);
      s->id = user_id;
      HASH_ADD_INT( users, id, s );  /* id: name of key field */
    }
    strcpy(s->name, name);
}
```

HASH_ADD_INT函数中，第一个参数users是哈希表，第二个参数id是键字段的名称。最后一个参数s是指向要添加的结构的指针。

### 查找

```c
struct my_struct *find_user(int user_id) {
    struct my_struct *s;
    HASH_FIND_INT( users, &user_id, s );  /* s: output pointer */
    return s;
}
```

在上述第三行代码中，第一个参数 users 是哈希表，**第二个参数是 user_id 的地址**（**一定要传递地址**）。

最后 s 是输出变量。当可以在哈希表中找到相应键值时，s 返回给定键的结构，当找不到时 s 返回 NULL。

### 替换

HASH_REPLACE宏等效于HASH_ADD宏，HASH_REPLACE会尝试查找和删除项目外。如果找到并删除了一个项目，它还将返回该项目的指针作为输出参数。

```go
void replace_user(HashHead *head, HashNode *newNode) {
    HashNode *oldNode = find_user(*head, newNode->id);
    if (oldNode)
        HASH_REPLACE_INT(*head, id, newNode, oldNode);
}
```

### 删除

要从哈希表中删除结构，必须具有指向它的指针。（如果只有键，请先执行HASH_FIND以获取结构指针）。

```c
void delete_user(struct my_struct *user) {
    HASH_DEL(users, user);  /* user: pointer to deletee */
    free(user);             /* optional; it's up to you! */
}
```

同样，这里users是哈希表，user是指向我们要从哈希中删除的结构的指针。

删除结构只是将其从哈希表中删除，并非free 。何时释放结构的选择完全取决于自己；uthash永远不会释放您的结构。

### 循环删除

HASH_ITER是一个宏定义，程序执行时被替换为一个循环。

```c
void delete_all() {
  struct my_struct *current_user, *tmp;

  HASH_ITER(hh, users, current_user, tmp) {
    HASH_DEL(users,current_user);  /* delete; users advances to next */
    free(current_user);            /* optional- if you want to free  */
  }
}
```

### 删除哈希表所有元素

如果您只想删除所有项目，但不释放它们或进行每个元素的清理，则可以通过一次操作更有效地做到这一点：

```c
HASH_CLEAR(hh,users);
```

之后，列表头（此处为users）将设置为NULL。

### 计算哈希表元素个数

```c
unsigned int num_users;
num_users = HASH_COUNT(users);
printf("there are %u users\n", num_users);
```

当users为NULL时，HASH_COUNT会返回0.

### 遍历哈希表中的所有项目

```c
void print_users() {
    struct my_struct *s;

    for(s=users; s != NULL; s=s->hh.next) {
        printf("user id %d: name %s\n", s->id, s->name);
    }
}
```

还有一个hh.prev指针，可用于从任何已知项开始向后迭代哈希。 由于hh.prev和hh.next字段的缘故，可以在哈希中向前和向后迭代。可以通过重复跟随这些指针来访问哈希中的所有项目，因此哈希也是**双链表**。

### 排序哈希表

```c
HASH_SORT( users, name_sort );
```

第二个参数是指向比较函数的指针。它必须接受两个指针参数（要比较的项目），并且如果第一个项目分别在第二个项目之前，等于或之后排序，则必须返回小于零，零或大于零的int。 （这与标准C库中的strcmp或qsort使用的约定相同）。

```c
int sort_function(void *a, void *b) {
  /* compare a to b (cast a and b appropriately)
   * return (int) -1 if (a < b)
   * return (int)  0 if (a == b)
   * return (int)  1 if (a > b)
   */
}
```

name_sort和id_sort的两个排序函数示例。

```c
int name_sort(struct my_struct *a, struct my_struct *b) {
    return strcmp(a->name,b->name);
}

int id_sort(struct my_struct *a, struct my_struct *b) {
    return (a->id - b->id);
}

void sort_by_name() {
    HASH_SORT(users, name_sort);
}

void sort_by_id() {
    HASH_SORT(users, id_sort);
}
```

