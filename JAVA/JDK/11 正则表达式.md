
正则表达式（Regular Expression）又称正规表示法、常规表示法，在代码中常简写为 regex、regexp 或 RE，它是计算机科学的一个概念。

- 正则表达式定义了字符串的模式。
- 正则表达式可以用来搜索、编辑或处理文本。
- 正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。
- Java 正则表达式和 Perl 的是最为相似的。

> 根据 Java Language Specification 的要求，Java 源代码的字符串中的反斜线被解释为 Unicode 转义或其他字符转义。因此必须在字符串字面值中使用两个反斜线，表示正则表达式受到保护，不被 Java 字节码编译器解释。例如，当解释为正则表达式时，字符串字面值 "\b" 与单个退格字符匹配，而 "\\b" 与单词边界匹配。字符串字面值 "\(hello\)" 是非法的，将导致编译时错误；要与字符串 (hello) 匹配，必须使用字符串字面值 "\\(hello\\)"。
>
> 也可以简单的理解在 Java 的正则表达式中，两个 `\\` 代表其他语言中的一个 `\`，也就是说像 \s 这样的表达式，在 Java 代码中你要写成这样 `"\\s"` 

## 基本

### 常用元字符

| 元字符      | 正则表达式中的写法 | 意义                       |
| ----------- | ------------------ | -------------------------- |
| `.`         | `.`                | 代表任意一个字符           |
| `\d`        | `\\d`              | 代表 0~9 中任意一个数字    |
| `\D`        | `\\D`              | 代表一个任意的非数字的字符 |
| `\s`        | `\\s`              | 代表空白字符，如 `\t` `\n` |
| `\S`        | `\\S`              | 代表非空白字符             |
| `\w`        | `\\w`              | 代表可以用作标识符的字符，不包括 `$` |
| `\W`        | `\\W`              |代表不可以用作标识符的字符|
| `\p{Lower}` | `\\p{Lower}`       | 代表小写字母 a-z |
| `\p{Upper}` | `\\p{Upper}` | 代表大写字母 A-Z |
| `\p{ASCII}` | `\\p{ASCII}` | 代表 ASCII |
| `\p{Digit}` | `\\p{Digit}` | 代表十进制数字 0-9 |
| `\p{Alnum}` | `\\p{Alnum}` | 代表数字或字母字符 |
| `\p{Punct}` | `\\p{Punct}` | 代表标点符号：`!"#$%&'()*+,-/:;<>=?@[\]^_{|}~` |
| `\p{Graph}` | `\\p{Graph}` | 代表可见字符 ：`[\p{Alnum}\p{Punct}]` |
| `\p{Print}` | `\\p{Print}` | 代表打印字符：`[\p{Graph}\x20]` |
| `\p{Blank}` | `\p{Blank}` | 代表空格或者制表符 |
| `p\{Cntrl}` | `\\p{Cntrl}` | 代表控制字符：`[\x00-\x1F\x7F]` |

### 在正则表达式中使用方括号

在正则表达式可以使用方括号括起来表示一个元字符

- `"[abc]4"` 表示 a4 b4 c4
- `[^456]` 表示 4 5 6 以外的所有数字
- `[a-r]` 表示 a-r 中任意一个字母
- `[a-e[g-z]]` 表示 a-e 和 g-z 之间任意一个字母（并运算）
-  `[a-o&&[def]]` 表示 d e f 中一个字母 （交运算）
- `[a-d&&[^b-c]]` 表示 a d 中一个字母 （差运算）

### 限定修饰符

在正则表示中允许使用限定修饰符来说明元字符出现的次数

| 限定修饰符 | 意义          | 示例     |
| ---------- | ------------- | -------- |
| `?`        | 0 次或 1 次   | `A?`     |
| `*`        | 0 次或多次    | `A*`     |
| `+`        | 一次或多次    | `A+`     |
| `{n}`      | 正好出现 n 次 | `A{n}`   |
| `{n,}`     | 至少出现 n 次 | `A{n,}`  |
| `{n,m}`    | 出现 n~m 次   | `A{n,m}` |

### 需要转义的字符

| 特殊字符 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| `$`      | 匹配一行的结尾。要匹配 $ 字符本身，请使用`\$`                |
| `^`      | 匹配一行的开头。要匹配 ^ 字符本身，请使用`\^`                |
| `()`     | 标记子表达式的开始和结束位置。要匹配这些字符，请使用`\(`和`\)` |
| `[]`     | 用于确定中括号表达式的开始和结束位置。要匹配这些字符，请使用`\[`和`\]` |
| `{}`     | 用于标记前面子表达式的出现频度。要匹配这些字符，请使用`\{`和`\}` |
| `*`      | 指定前面子表达式可以出现零次或多次。要匹配 * 字符本身，请使用`\*` |
| `+`      | 指定前面子表达式可以出现一次或多次。要匹配 + 字符本身，请使用`\+` |
| `?`      | 指定前面子表达式可以出现零次或一次。要匹配 ？字符本身，请使用`\?` |
| `.`      | 匹配除换行符`\n`之外的任何单字符。要匹配`.`字符本身，请使用`\.` |
| `\`      | 用于转义下一个字符，或指定八进制、十六进制字符。如果需匹配`\`字符，请用`\\` |
| `|`      | 指定两项之间任选一项。如果要匹配`丨`字符本身，请使用`\|`     |


### 元字符的补充

若需要匹配所有的中文字符，就可以利用 `[\\u0041-\\u0056]` 形式——因为所有中文字符的 Unicode 值是连续的，只要找出所有中文字符中最小、最大的 Unicode 值，就可以利用上面形式来匹配所有的中文字符。

| 字符   | 解释                                                         |
| ------ | ------------------------------------------------------------ |
| X      | 字符x（x 可代表任何合法的字符)                               |
| \0mnn  | 八进制数 0mnn 所表示的字符                                   |
| \xhh   | 十六进制值 0xhh 所表示的字符                                 |
| \uhhhh | 十六进制值 0xhhhh 所表示的 Unicode 字符                      |
| \t     | 制表符（“\u0009”）                                           |
| \n     | 新行（换行）符（‘\u000A’）                                   |
| \r     | 回车符（‘\u000D’)                                            |
| \f     | 换页符（‘\u000C’）                                           |
| \a     | 报警（bell）符（‘\u0007’）                                   |
| \e     | Escape 符（‘\u001B’）                                        |
| \cx    | x 对应的的控制符。例如，`\cM`匹配 Ctrl-M。x 值必须为 A~Z 或 a~z 之一。 |
| (*pattern*)   | 匹配 *pattern* 并捕获该匹配的子表达式。可以使用 **$0…$9** 属性从结果"匹配"集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用"\("或者"\)"。 |
| (?:*pattern*) | 匹配 *pattern* 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用"or"字符 (\|) 组合模式部件的情况很有用。例如，'industr(?:y\|ies) 是比 'industry\|industries' 更经济的表达式。 |
| (?=*pattern*) | 执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 *pattern* 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows (?=95\|98\|NT\|2000)' 匹配"Windows 2000"中的"Windows"，但不匹配"Windows 3.1"中的"Windows"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。 |
| (?!*pattern*) | 执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 *pattern* 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows (?!95\|98\|NT\|2000)' 匹配"Windows 3.1"中的 "Windows"，但不匹配"Windows 2000"中的"Windows"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。 |
| *x*\|*y*      | 匹配 *x* 或 *y*。例如，'z\|food' 匹配"z"或"food"。'(z\|f)ood' 匹配"zood"或"food"。 |
| \b    | 匹配一个字边界，即字与空格间的位置。例如，"er\b"匹配"never"中的"er"，但不匹配"verb"中的"er"。 |
| \B    | 非字边界匹配。"er\B"匹配"verb"中的"er"，但不匹配"never"中的"er"。 |
| \c*x* | 匹配 *x* 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。*x* 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是"c"字符本身。 |
| \n   | 换行符匹配。等效于 \x0a 和 \cJ。     |
| \r   | 匹配一个回车符。等效于 \x0d 和 \cM。 |
| \t   | 制表符匹配。与 \x09 和 \cI 等效。     |
| \v   | 垂直制表符匹配。与 \x0b 和 \cK 等效。 |
| \x*n*  | 匹配 *n*，此处的 *n* 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，"\x41"匹配"A"。"\x041"与"\x04"&"1"等效。允许在正则表达式中使用 ASCII 代码。 |
| \*num* | 匹配 *num*，此处的 *num* 是一个正整数。到捕获匹配的反向引用。例如，"(.)\1"匹配两个连续的相同字符。 |
| \*n*   | 标识一个八进制转义码或反向引用。如果 \*n* 前面至少有 *n* 个捕获子表达式，那么 *n* 是反向引用。否则，如果 *n* 是八进制数 (0-7)，那么 *n* 是八进制转义码。 |
| \*nm*  | 标识一个八进制转义码或反向引用。如果 \*nm* 前面至少有 *nm* 个捕获子表达式，那么 *nm* 是反向引用。如果 \*nm* 前面至少有 *n* 个捕获，则 *n* 是反向引用，后面跟有字符 *m*。如果两种前面的情况都不存在，则 \*nm* 匹配八进制值 *nm*，其中 *n* 和 *m* 是八进制数字 (0-7)。 |
| \nml   | 当 *n* 是八进制数 (0-3)，*m* 和 *l* 是八进制数 (0-7) 时，匹配八进制转义码 *nml*。 |
| \u*n*  | 匹配 *n*，其中 *n* 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。 |

### 一些例子

```
"\u0041\\\\" // 匹配 A\
"\u0061\t"  // 匹配a<制表符>
"\\?\\["    // 匹配？[
c\\wt    // 可以匹配cat、cbt、cct、cOt、c9t等一批字符串
\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d    // 匹配如 000-000-0000 形式的电话号码
```

### 匹配模式

一个匹配 000-000-0000 形式的电话号码时，使用了 \\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d 正则表达式，这看起来比较烦琐。实际上，正则表达式还提供了数量标识符，正则表达式支持的数量标识符有如下几种模式。

- Greedy（贪婪模式）：数量表示符默认采用贪婪模式，除非另有表示。贪婪模式的表达式会一直匹配下去，直到无法匹配为止。如果你发现表达式匹配的结果与预期的不符，很有可能是因为你以为表达式只会匹配前面几个字符，而实际上它是贪婪模式，所以会一直匹配下去。
- Reluctant（勉强模式）：用问号后缀（?）表示，它只会匹配最少的字符。也称为最小匹配模式。
- Possessive（占有模式）：用加号后缀（+）表示，目前只有 Java 支持占有模式，通常比较少用。

## Pattern 和 Matcher

- java.util.regex 是一个用正则表达式所订制的模式来对字符串进行匹配工作的类库包。它包括两个类：Pattern 和 Matcher。

- Pattern 对象是正则表达式编译后在内存中的表示形式，因此，正则表达式字符串必须先被编译为 Pattern 对象

- 然后再利用该 Pattern 对象创建对应的 Matcher 对象。执行匹配所涉及的状态保留在 Matcher 对象中，多个 Matcher 对象可共享同一个 Pattern 对象。
