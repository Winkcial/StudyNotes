
在C语言中，用一个指针变量指向一个文件，这个指针称为文件指针。通过文件指针就可对它所指的文件进行各种操作。

定义文件指针的一般形式为：

```c
FILE  *fp;
```

这里的FILE，实际上是在stdio.h中定义的一个结构体，该结构体中含有文件名、文件状态和文件当前位置等信息，fopen 返回的就是FILE类型的指针。

> 注意：FILE是文件缓冲区的结构，fp也是指向文件缓冲区的指针。

不同编译器 stdio.h 头文件中对 FILE 的定义略有差异，这里以标准C举例说明：

```c
typedef struct _iobuf {
    int cnt;  // 剩余的字符，如果是输入缓冲区，那么就表示缓冲区中还有多少个字符未被读取
    char *ptr;  // 下一个要被读取的字符的地址
    char *base;  // 缓冲区基地址
    int flag;  // 读写状态标志位
    int fd;  // 文件描述符
    // 其他成员
} FILE;
```

下面说一下如果控制缓冲区。

我们知道，当我们从键盘输入数据的时候，数据并不是直接被我们得到，而是放在了缓冲区中，然后我们从缓冲区中得到我们想要的数据 。如果我们通过setbuf()或setvbuf()函数将缓冲区设置10个字节的大小，而我们从键盘输入了20个字节大小的数据，这样我们输入的前10个数据会放在缓冲区中，因为我们设置的缓冲区的大小只能够装下10个字节大小的数据，装不下20个字节大小的数据。那么剩下的那10个字节大小的数据怎么办呢？暂时放在了输入流中。请看下图：

![no.1](https://images-1302683597.cos.ap-nanjing.myqcloud.com/images/StudyNotes/C/images_20220327231107.png)

上面的箭头表示的区域就相当是一个输入流，红色的地方相当于一个开关，这个开关可以控制往深绿色区域（标注的是缓冲区）里放进去的数据，输入20个字节的数据只往缓冲区中放进去了10个字节，剩下的10个字节的数据就被停留在了输入流里！等待下去往缓冲区中放入！接下来系统是如何来控制这个缓冲区呢？

再说一下 FILE 结构体中几个相关成员的含义：
  cnt  // 剩余的字符，如果是输入缓冲区，那么就表示缓冲区中还有多少个字符未被读取
  ptr  // 下一个要被读取的字符的地址
  base  // 缓冲区基地址

在上面我们向缓冲区中放入了10个字节大小的数据，FILE结构体中的 cnt 变为了10 ，说明此时缓冲区中有10个字节大小的数据可以读，同时我们假设缓冲区的基地址也就是 base 是0x00428e60 ，它是不变的 ，而此时 ptr 的值也为0x00428e60 ，表示从0x00428e60这个位置开始读取数据，当我们从缓冲区中读取5个数据的时候，cnt 变为了5 ，表示缓冲区还有5个数据可以读，ptr 则变为了0x0042e865表示下次应该从这个位置开始读取缓冲区中的数据 ，如果接下来我们再读取5个数据的时候，cnt 则变为了0 ，表示缓冲区中已经没有任何数据了，ptr 变为了0x0042869表示下次应该从这个位置开始从缓冲区中读取数据，但是此时缓冲区中已经没有任何数据了，所以要将输入流中的剩下的那10个数据放进来，这样缓冲区中又有了10个数据，此时 cnt 变为了10 ，注意了刚才我们讲到 ptr 的值是0x00428e69 ，而当缓冲区中重新放进来数据的时候这个 ptr 的值变为了0x00428e60 ，这是因为当缓冲区中没有任何数据的时候要将 ptr 这个值进行一下刷新，使其指向缓冲区的基地址也就是0x0042e860这个值！因为下次要从这个位置开始读取数据！

在这里有点需要说明：当我们从键盘输入字符串的时候需要敲一下回车键才能够将这个字符串送入到缓冲区中，那么敲入的这个回车键(\r)会被转换为一个换行符\n，这个换行符\n也会被存储在缓冲区中并且被当成一个字符来计算！比如我们在键盘上敲下了123456这个字符串，然后敲一下回车键（\r）将这个字符串送入了缓冲区中，那么此时缓冲区中的字节个数是7 ，而不是6。

**缓冲区的刷新就是将指针 ptr 变为缓冲区的基地址 ，同时 cnt 的值变为0 ，因为缓冲区刷新后里面是没有数据的！**