# 浮点数运算

- 浮点数加减运算
- 强制类型转换

## 加减运算

- 对阶
- 尾数加减
- 规格化
- 舍入
- 判断溢出

已知十进制数 $-5/256$ 和 $+59/20124$ ，按机器补码浮点运算规则计算 $X-Y$ ，结果用二进制表示，浮点数格式如下，阶符取 2位，阶码取 3 位，数符取 2 位，尾数取 9 位。

X=11,011;11,011000000

Y=11,100;00,111011000

### 对阶

使两个数的阶码相同，小阶向大阶对齐，尾数每右移一位阶码加一

**为何小阶向大阶对齐？**

答：计算机内部尾数是定点小数

**计算机如何知晓哪一个阶码是小阶？**

答：两个阶码做差
- $|\Delta E|_{补}=[x]_{补}-[y]_{补}=[x]_{补}+[-y]_{补}=110111+00100=11111$
- $\Delta E=-1$
- -1 代表 X 的阶数比 Y 的阶数小，并且是少一个值
- X 的阶码向加1，同时尾数右移一位
- X'=11,100;11,101100000（补码右移高位补一）

### 尾数加减

- 两个尾数相减：$[x]_{补}-[y]_{补}=[x]_{补}+[-y]_{补}$
- 求 $[-y]_{补}=11,000 101 000$
- $[x]_{补}+[-y]_{补}=11,101100000+11,000101000=10,110001000$

这里 发生了溢出，我们可以通过右规的方式拯救溢出

### 规格化

- 尾数算数右移 $X-Y=11,100;10,110001000$ $\rightarrow$ $11,101;11,011000100$
- 阶码加一：11,100 $\rightarrow$ 11,101

### 舍入

在这个例子中规格化的第一步尾数算数右移抛弃的是 0 ，没有丢失精度，我们也就不考虑了

**“0” 舍 “1” 入法**，类似于十进制中的四舍五入法

- 在尾数右移时，被遗弃的最高位数值为 0 ，则舍弃
- 被遗弃的最高位数值为 1，则在尾数的末尾加一，这样做可能又会发生溢出，需要再做一次右规

现在来看一个例子

- 某两个尾数相加后的结果是：11,100；10.11000101
- 规格化：11,100；10.11000101 $\rightarrow$ 尾数右移舍弃一位 1 得到  11,101;11,01100010 
- $(1)_{2}$ 舍弃的部分最高位是 1 所以在上一步的结果上加一 
- 最终的结果是：11,101;11,01100011

**恒置 “1” 法**：尾数右移时，不论丢弃的最高位数值是 “1” 还是 “0”，都使右移后的尾数末位恒置 “1”，这种方法可能使尾数变大或者变小

### 判断溢出

阶码加一，看符号位是否相同

最终的真值是 $11,101;11,011000100$






